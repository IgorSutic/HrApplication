{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_data_provider.js)\r\n * Version: 21.1.6\r\n * Build date: Mon Sep 27 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nvar _excluded = [\"startDate\", \"endDate\", \"isFirstGroupCell\", \"isLastGroupCell\"],\n    _excluded2 = [\"allDay\", \"startDate\", \"endDate\"];\nimport dateUtils from \"../../../core/utils/date\";\nimport { HORIZONTAL_GROUP_ORIENTATION } from \"../constants\";\n\nclass ViewDataGenerator {\n  constructor(workspace) {\n    this.workspace = workspace;\n  }\n\n  get workspace() {\n    return this._workspace;\n  }\n\n  set workspace(value) {\n    this._workspace = value;\n  }\n\n  get isVerticalGroupedWorkspace() {\n    return this.workspace._isVerticalGroupedWorkSpace();\n  }\n\n  get isStandaloneAllDayPanel() {\n    return !this.isVerticalGroupedWorkspace && this.workspace.isAllDayPanelVisible;\n  }\n\n  _getCompleteViewDataMap(options) {\n    var {\n      rowCountInGroup: rowCountInGroup,\n      cellCountInGroupRow: cellCountInGroupRow,\n      groupsList: groupsList,\n      groupByDate: groupByDate,\n      isHorizontalGrouping: isHorizontalGrouping,\n      isVerticalGrouping: isVerticalGrouping,\n      totalCellCount: totalCellCount,\n      groupCount: groupCount\n    } = options;\n    var viewDataMap = [];\n    var step = groupByDate ? groupCount : 1;\n\n    var allDayPanelData = this._generateAllDayPanelData(options, cellCountInGroupRow, step);\n\n    var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, step);\n\n    allDayPanelData && viewDataMap.push(allDayPanelData);\n    viewDataMap.push(...viewCellsData);\n\n    if (isHorizontalGrouping && !groupByDate) {\n      viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList);\n    }\n\n    if (isVerticalGrouping) {\n      viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList);\n    }\n\n    if (groupByDate) {\n      viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList);\n    }\n\n    var completeViewDataMap = this._addKeysToCells(viewDataMap, totalCellCount);\n\n    return completeViewDataMap;\n  }\n\n  _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\n    var result = viewDataMap.map(row => row.slice());\n    groupsList.slice(1).forEach((groups, index) => {\n      var groupIndex = index + 1;\n      viewDataMap.forEach((row, rowIndex) => {\n        var nextGroupRow = row.map(cellData => _extends({}, cellData, {\n          groups: groups,\n          groupIndex: groupIndex\n        }));\n        result[rowIndex].push(...nextGroupRow);\n      });\n    });\n    return result;\n  }\n\n  _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\n    var result = viewDataMap.map(row => row.slice());\n    groupsList.slice(1).forEach((groups, index) => {\n      var groupIndex = index + 1;\n      var nextGroupMap = viewDataMap.map(cellsRow => {\n        var nextRow = cellsRow.map(cellData => _extends({}, cellData, {\n          groupIndex: groupIndex,\n          groups: groups\n        }));\n        return nextRow;\n      });\n      result.push(...nextGroupMap);\n    });\n    return result;\n  }\n\n  _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\n    var correctedGroupList = groupsList.slice(1);\n    var correctedGroupCount = correctedGroupList.length;\n    var result = viewDataMap.map(cellsRow => {\n      var groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {\n        var rowWithCurrentCell = [...currentRow, _extends({}, cell, {\n          isFirstGroupCell: true,\n          isLastGroupCell: 0 === correctedGroupCount\n        }), ...correctedGroupList.map((groups, index) => _extends({}, cell, {\n          groups: groups,\n          groupIndex: index + 1,\n          isFirstGroupCell: false,\n          isLastGroupCell: index === correctedGroupCount - 1\n        }))];\n        return rowWithCurrentCell;\n      }, []);\n      return groupedByDateCellsRow;\n    });\n    return result;\n  }\n\n  _addKeysToCells(viewDataMap, totalColumnCount) {\n    var {\n      currentViewDataMap: result\n    } = viewDataMap.reduce((_ref, row, rowIndex) => {\n      var {\n        allDayPanelsCount: allDayPanelsCount,\n        currentViewDataMap: currentViewDataMap\n      } = _ref;\n      var isAllDay = row[0].allDay;\n      var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\n      var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\n      currentViewDataMap[rowIndex].forEach((cell, cellIndex) => {\n        cell.key = keyBase + cellIndex;\n      });\n      return {\n        allDayPanelsCount: currentAllDayPanelsCount,\n        currentViewDataMap: currentViewDataMap\n      };\n    }, {\n      allDayPanelsCount: 0,\n      currentViewDataMap: viewDataMap\n    });\n    return result;\n  }\n\n  _getCompleteDateHeaderMap(options, completeViewDataMap) {\n    var {\n      isGenerateWeekDaysHeaderData: isGenerateWeekDaysHeaderData\n    } = options;\n    var result = [];\n\n    if (isGenerateWeekDaysHeaderData) {\n      var weekDaysRow = this._generateWeekDaysHeaderRowMap(options, completeViewDataMap);\n\n      result.push(weekDaysRow);\n    }\n\n    var dateRow = this._generateHeaderDateRow(options, completeViewDataMap);\n\n    result.push(dateRow);\n    return result;\n  }\n\n  _generateWeekDaysHeaderRowMap(options, completeViewDataMap) {\n    var {\n      groupByDate: groupByDate,\n      horizontalGroupCount: horizontalGroupCount,\n      cellCountInDay: cellCountInDay,\n      getWeekDaysHeaderText: getWeekDaysHeaderText,\n      daysInView: daysInView\n    } = options;\n    var index = completeViewDataMap[0][0].allDay ? 1 : 0;\n    var colSpan = groupByDate ? horizontalGroupCount * cellCountInDay : cellCountInDay;\n    var weekDaysRow = [];\n\n    for (var dayIndex = 0; dayIndex < daysInView; dayIndex += 1) {\n      var cell = completeViewDataMap[index][dayIndex * colSpan];\n      weekDaysRow.push(_extends({}, cell, {\n        colSpan: colSpan,\n        text: getWeekDaysHeaderText(cell.startDate),\n        isFirstGroupCell: false,\n        isLastGroupCell: false\n      }));\n    }\n\n    return weekDaysRow;\n  }\n\n  _generateHeaderDateRow(options, completeViewDataMap) {\n    var {\n      getDateHeaderText: getDateHeaderText,\n      today: today,\n      groupByDate: groupByDate,\n      horizontalGroupCount: horizontalGroupCount,\n      cellCountInGroupRow: cellCountInGroupRow,\n      groupOrientation: groupOrientation,\n      getDateHeaderDate: getDateHeaderDate\n    } = options;\n    var dates = [];\n\n    for (var dateIndex = 0; dateIndex < cellCountInGroupRow; dateIndex += 1) {\n      dates.push(getDateHeaderDate(dateIndex));\n    }\n\n    var index = completeViewDataMap[0][0].allDay ? 1 : 0;\n    var colSpan = groupByDate ? horizontalGroupCount : 1;\n    var isVerticalGrouping = \"vertical\" === groupOrientation;\n    var slicedByColumnsData = groupByDate ? completeViewDataMap[index].filter((_, columnIndex) => columnIndex % horizontalGroupCount === 0) : completeViewDataMap[index];\n    return slicedByColumnsData.map((_ref2, index) => {\n      var {\n        startDate: startDate,\n        isFirstGroupCell: isFirstGroupCell,\n        isLastGroupCell: isLastGroupCell\n      } = _ref2,\n          restProps = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n      return _extends({}, restProps, {\n        startDate: dates[index % cellCountInGroupRow],\n        text: getDateHeaderText(index % cellCountInGroupRow),\n        today: dateUtils.sameDate(startDate, today),\n        colSpan: colSpan,\n        isFirstGroupCell: groupByDate || isFirstGroupCell && !isVerticalGrouping,\n        isLastGroupCell: groupByDate || isLastGroupCell && !isVerticalGrouping\n      });\n    });\n  }\n\n  _getCompleteTimePanelMap(options, completeViewDataMap) {\n    var {\n      rowCountInGroup: rowCountInGroup,\n      getTimeCellDate: getTimeCellDate\n    } = options;\n    var times = [];\n\n    for (var rowIndex = 0; rowIndex < rowCountInGroup; rowIndex += 1) {\n      times.push(getTimeCellDate(rowIndex));\n    }\n\n    var allDayRowsCount = 0;\n    return completeViewDataMap.map((row, index) => {\n      var _row$ = row[0],\n          {\n        allDay: allDay,\n        startDate: startDate\n      } = _row$,\n          restCellProps = _objectWithoutPropertiesLoose(_row$, _excluded2);\n\n      if (allDay) {\n        allDayRowsCount += 1;\n      }\n\n      var timeIndex = (index - allDayRowsCount) % rowCountInGroup;\n      return _extends({}, restCellProps, {\n        allDay: allDay,\n        startDate: allDay ? startDate : times[timeIndex]\n      });\n    });\n  }\n\n  _generateViewDataMap(completeViewDataMap, options) {\n    var {\n      rowCount: rowCount,\n      startCellIndex: startCellIndex,\n      cellCount: cellCount\n    } = options;\n    var {\n      startRowIndex: startRowIndex\n    } = options;\n\n    var sliceCells = (row, rowIndex, startIndex, count) => row.slice(startIndex, startIndex + count).map((cellData, cellIndex) => ({\n      cellData: cellData,\n      position: {\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      }\n    }));\n\n    var correctedStartRowIndex = startRowIndex;\n    var allDayPanelMap = [];\n\n    if (this.isStandaloneAllDayPanel) {\n      correctedStartRowIndex++;\n      allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount);\n    }\n\n    var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + rowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));\n    return {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    };\n  }\n\n  _generateDateHeaderData(completeDateHeaderMap, options) {\n    var {\n      isGenerateWeekDaysHeaderData: isGenerateWeekDaysHeaderData,\n      cellCountInDay: cellCountInDay,\n      cellWidth: cellWidth,\n      isProvideVirtualCellsWidth: isProvideVirtualCellsWidth\n    } = options;\n    var dataMap = [];\n    var weekDayRowConfig = {};\n    var validCellWidth = cellWidth || 0;\n\n    if (isGenerateWeekDaysHeaderData) {\n      weekDayRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, cellCountInDay, 0, validCellWidth);\n      dataMap.push(weekDayRowConfig.dateRow);\n    }\n\n    var datesRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, 1, isGenerateWeekDaysHeaderData ? 1 : 0, validCellWidth);\n\n    dataMap.push(datesRowConfig.dateRow);\n    return {\n      dataMap: dataMap,\n      leftVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.leftVirtualCellWidth : void 0,\n      rightVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.rightVirtualCellWidth : void 0,\n      leftVirtualCellCount: datesRowConfig.leftVirtualCellCount,\n      rightVirtualCellCount: datesRowConfig.rightVirtualCellCount,\n      weekDayLeftVirtualCellWidth: weekDayRowConfig.leftVirtualCellWidth,\n      weekDayRightVirtualCellWidth: weekDayRowConfig.rightVirtualCellWidth,\n      weekDayLeftVirtualCellCount: weekDayRowConfig.leftVirtualCellCount,\n      weekDayRightVirtualCellCount: weekDayRowConfig.rightVirtualCellCount\n    };\n  }\n\n  _generateDateHeaderDataRow(options, completeDateHeaderMap, baseColSpan, rowIndex, cellWidth) {\n    var {\n      groupByDate: groupByDate,\n      horizontalGroupCount: horizontalGroupCount,\n      startCellIndex: startCellIndex,\n      cellCount: cellCount,\n      totalCellCount: totalCellCount,\n      isProvideVirtualCellsWidth: isProvideVirtualCellsWidth\n    } = options;\n    var colSpan = groupByDate ? horizontalGroupCount * baseColSpan : baseColSpan;\n    var leftVirtualCellCount = Math.floor(startCellIndex / colSpan);\n    var actualCellCount = Math.ceil((startCellIndex + cellCount) / colSpan);\n    var dateRow = completeDateHeaderMap[rowIndex].slice(leftVirtualCellCount, actualCellCount);\n    var finalLeftVirtualCellCount = leftVirtualCellCount * colSpan;\n    var finalLeftVirtualCellWidth = finalLeftVirtualCellCount * cellWidth;\n    var finalRightVirtualCellCount = totalCellCount - actualCellCount * colSpan;\n    var finalRightVirtualCellWidth = finalRightVirtualCellCount * cellWidth;\n    return {\n      dateRow: dateRow,\n      leftVirtualCellCount: finalLeftVirtualCellCount,\n      leftVirtualCellWidth: isProvideVirtualCellsWidth ? finalLeftVirtualCellWidth : void 0,\n      rightVirtualCellCount: finalRightVirtualCellCount,\n      rightVirtualCellWidth: isProvideVirtualCellsWidth ? finalRightVirtualCellWidth : void 0\n    };\n  }\n\n  _generateTimePanelData(completeTimePanelMap, options) {\n    var {\n      startRowIndex: startRowIndex,\n      rowCount: rowCount,\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      cellCountInGroupRow: cellCountInGroupRow\n    } = options;\n    var isGroupedAllDayPanel = this.workspace.isGroupedAllDayPanel();\n    var showAllDayPanel = this.workspace.isAllDayPanelVisible;\n    var indexDifference = this.isVerticalGroupedWorkspace || !showAllDayPanel ? 0 : 1;\n    var correctedStartRowIndex = startRowIndex + indexDifference;\n    var timePanelMap = completeTimePanelMap.slice(correctedStartRowIndex, correctedStartRowIndex + rowCount);\n    var timePanelData = {\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      isGroupedAllDayPanel: isGroupedAllDayPanel,\n      cellCountInGroupRow: cellCountInGroupRow\n    };\n\n    var {\n      previousGroupedData: groupedData\n    } = this._generateTimePanelDataFromMap(timePanelMap, isGroupedAllDayPanel);\n\n    timePanelData.groupedData = groupedData;\n    return timePanelData;\n  }\n\n  _generateTimePanelDataFromMap(timePanelMap, isGroupedAllDayPanel) {\n    return timePanelMap.reduce((_ref3, cellData) => {\n      var {\n        previousGroupIndex: previousGroupIndex,\n        previousGroupedData: previousGroupedData\n      } = _ref3;\n      var currentGroupIndex = cellData.groupIndex;\n\n      if (currentGroupIndex !== previousGroupIndex) {\n        previousGroupedData.push({\n          dateTable: [],\n          isGroupedAllDayPanel: isGroupedAllDayPanel,\n          groupIndex: currentGroupIndex\n        });\n      }\n\n      if (cellData.allDay) {\n        previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellData;\n      } else {\n        previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellData);\n      }\n\n      return {\n        previousGroupIndex: currentGroupIndex,\n        previousGroupedData: previousGroupedData\n      };\n    }, {\n      previousGroupIndex: -1,\n      previousGroupedData: []\n    });\n  }\n\n  _getViewDataFromMap(viewDataMap, options) {\n    var {\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      leftVirtualCellWidth: leftVirtualCellWidth,\n      rightVirtualCellWidth: rightVirtualCellWidth,\n      cellCountInGroupRow: cellCountInGroupRow,\n      totalCellCount: totalCellCount,\n      totalRowCount: totalRowCount,\n      cellCount: cellCount,\n      rowCount: rowCount,\n      startRowIndex: startRowIndex,\n      startCellIndex: startCellIndex,\n      isProvideVirtualCellsWidth: isProvideVirtualCellsWidth\n    } = options;\n    var isGroupedAllDayPanel = this.workspace.isGroupedAllDayPanel();\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var {\n      previousGroupedData: groupedData\n    } = dateTableMap.reduce((_ref4, cellsRow) => {\n      var {\n        previousGroupIndex: previousGroupIndex,\n        previousGroupedData: previousGroupedData\n      } = _ref4;\n      var cellDataRow = cellsRow.map(_ref5 => {\n        var {\n          cellData: cellData\n        } = _ref5;\n        return cellData;\n      });\n      var firstCell = cellDataRow[0];\n      var isAllDayRow = firstCell.allDay;\n      var currentGroupIndex = firstCell.groupIndex;\n\n      if (currentGroupIndex !== previousGroupIndex) {\n        previousGroupedData.push({\n          dateTable: [],\n          isGroupedAllDayPanel: isGroupedAllDayPanel,\n          groupIndex: currentGroupIndex\n        });\n      }\n\n      if (isAllDayRow) {\n        previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellDataRow;\n      } else {\n        previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellDataRow);\n      }\n\n      return {\n        previousGroupedData: previousGroupedData,\n        previousGroupIndex: currentGroupIndex\n      };\n    }, {\n      previousGroupIndex: -1,\n      previousGroupedData: []\n    });\n\n    if (this.isStandaloneAllDayPanel) {\n      groupedData[0].allDayPanel = allDayPanelMap.map(_ref6 => {\n        var {\n          cellData: cellData\n        } = _ref6;\n        return cellData;\n      });\n    }\n\n    return {\n      groupedData: groupedData,\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\n      rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\n      cellCountInGroupRow: cellCountInGroupRow,\n      isGroupedAllDayPanel: isGroupedAllDayPanel,\n      leftVirtualCellCount: startCellIndex,\n      rightVirtualCellCount: totalCellCount - startCellIndex - cellCount,\n      topVirtualRowCount: startRowIndex,\n      bottomVirtualRowCount: totalRowCount - startRowIndex - rowCount\n    };\n  }\n\n  _generateViewCellsData(options, rowsCount) {\n    var step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n    var {\n      cellCountInGroupRow: cellCountInGroupRow,\n      cellDataGetters: cellDataGetters\n    } = options;\n    var viewCellsData = [];\n\n    for (var rowIndex = 0; rowIndex < rowsCount; rowIndex += 1) {\n      viewCellsData.push(this._generateCellsRow(options, cellDataGetters, rowIndex, cellCountInGroupRow, step));\n    }\n\n    return viewCellsData;\n  }\n\n  _generateAllDayPanelData(options, cellCount) {\n    var step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n    var workSpace = this.workspace;\n\n    if (!workSpace.isAllDayPanelVisible) {\n      return null;\n    }\n\n    return this._generateCellsRow(options, [workSpace._getAllDayCellData.bind(workSpace)], 0, cellCount, step);\n  }\n\n  _generateCellsRow(options, cellDataGetters, rowIndex, columnCount, step) {\n    var _this = this;\n\n    var cellsRow = [];\n\n    var _loop = function (columnIndex) {\n      var correctedColumnIndex = step * columnIndex;\n      var cellDataValue = cellDataGetters.reduce((data, getter) => _extends({}, data, getter(void 0, rowIndex, correctedColumnIndex, 0, data.startDate).value), {});\n      cellDataValue.index = rowIndex * columnCount + columnIndex;\n      cellDataValue.isFirstGroupCell = _this._isFirstGroupCell(rowIndex, columnIndex, options);\n      cellDataValue.isLastGroupCell = _this._isLastGroupCell(rowIndex, columnIndex, options);\n      cellsRow.push(cellDataValue);\n    };\n\n    for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\n      _loop(columnIndex);\n    }\n\n    return cellsRow;\n  }\n\n  _calculateCellIndex(horizontalGroupCount, groupOrientation, isGroupedByDate, rowIndex, columnIndex, columnsNumber) {\n    var groupCount = horizontalGroupCount || 1;\n    var index = rowIndex * columnsNumber + columnIndex;\n    var columnsInGroup = columnsNumber / groupCount;\n\n    if (\"horizontal\" === groupOrientation) {\n      var columnIndexInCurrentGroup = columnIndex % columnsInGroup;\n\n      if (isGroupedByDate) {\n        columnIndexInCurrentGroup = Math.floor(columnIndex / groupCount);\n      }\n\n      index = rowIndex * columnsInGroup + columnIndexInCurrentGroup;\n    }\n\n    return index;\n  }\n\n  generateGroupedDataMap(viewDataMap) {\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var {\n      previousGroupedDataMap: dateTableGroupedMap\n    } = dateTableMap.reduce((previousOptions, cellsRow) => {\n      var {\n        previousGroupedDataMap: previousGroupedDataMap,\n        previousRowIndex: previousRowIndex,\n        previousGroupIndex: previousGroupIndex\n      } = previousOptions;\n      var {\n        groupIndex: currentGroupIndex\n      } = cellsRow[0].cellData;\n      var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\n      cellsRow.forEach(cell => {\n        var {\n          groupIndex: groupIndex\n        } = cell.cellData;\n\n        if (!previousGroupedDataMap[groupIndex]) {\n          previousGroupedDataMap[groupIndex] = [];\n        }\n\n        if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\n          previousGroupedDataMap[groupIndex][currentRowIndex] = [];\n        }\n\n        previousGroupedDataMap[groupIndex][currentRowIndex].push(cell);\n      });\n      return {\n        previousGroupedDataMap: previousGroupedDataMap,\n        previousRowIndex: currentRowIndex,\n        previousGroupIndex: currentGroupIndex\n      };\n    }, {\n      previousGroupedDataMap: [],\n      previousRowIndex: -1,\n      previousGroupIndex: -1\n    });\n    var allDayPanelGroupedMap = [];\n    null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(cell => {\n      var {\n        groupIndex: groupIndex\n      } = cell.cellData;\n\n      if (!allDayPanelGroupedMap[groupIndex]) {\n        allDayPanelGroupedMap[groupIndex] = [];\n      }\n\n      allDayPanelGroupedMap[groupIndex].push(cell);\n    });\n    return {\n      allDayPanelGroupedMap: allDayPanelGroupedMap,\n      dateTableGroupedMap: dateTableGroupedMap\n    };\n  }\n\n  _isFirstGroupCell(rowIndex, columnIndex, options) {\n    var {\n      groupOrientation: groupOrientation,\n      rowCountInGroup: rowCountInGroup,\n      cellCountInGroupRow: cellCountInGroupRow,\n      groupCount: groupCount\n    } = options;\n\n    if (this.workspace.isGroupedByDate()) {\n      return columnIndex % groupCount === 0;\n    }\n\n    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n      return columnIndex % cellCountInGroupRow === 0;\n    }\n\n    return rowIndex % rowCountInGroup === 0;\n  }\n\n  _isLastGroupCell(rowIndex, columnIndex, options) {\n    var {\n      groupOrientation: groupOrientation,\n      rowCountInGroup: rowCountInGroup,\n      cellCountInGroupRow: cellCountInGroupRow,\n      groupCount: groupCount\n    } = options;\n\n    if (this.workspace.isGroupedByDate()) {\n      return (columnIndex + 1) % groupCount === 0;\n    }\n\n    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n      return (columnIndex + 1) % cellCountInGroupRow === 0;\n    }\n\n    return (rowIndex + 1) % rowCountInGroup === 0;\n  }\n\n}\n\nclass GroupedDataMapProvider {\n  constructor(viewDataGenerator, viewDataMap, completeViewDataMap, workspace) {\n    this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);\n    this.completeViewDataMap = completeViewDataMap;\n    this._workspace = workspace;\n  }\n\n  get isVerticalGroupedWorkspace() {\n    return this._workspace._isVerticalGroupedWorkSpace();\n  }\n\n  getGroupStartDate(groupIndex) {\n    var firstRow = this.getFirstGroupRow(groupIndex);\n\n    if (firstRow) {\n      var {\n        startDate: startDate\n      } = firstRow[0].cellData;\n      return startDate;\n    }\n  }\n\n  getGroupEndDate(groupIndex) {\n    var lastRow = this.getLastGroupRow(groupIndex);\n\n    if (lastRow) {\n      var lastCellIndex = lastRow.length - 1;\n      var {\n        cellData: cellData\n      } = lastRow[lastCellIndex];\n      var {\n        endDate: endDate\n      } = cellData;\n      return endDate;\n    }\n  }\n\n  findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay) {\n    if (isAllDay) {\n      return this.findAllDayGroupCellStartDate(groupIndex, startDate);\n    }\n\n    var groupData = this.getGroupFromDateTableGroupMap(groupIndex);\n\n    var checkCellStartDate = (rowIndex, cellIndex) => {\n      var {\n        cellData: cellData\n      } = groupData[rowIndex][cellIndex];\n      var {\n        startDate: secondMin,\n        endDate: secondMax\n      } = cellData;\n\n      if (dateUtils.intervalsOverlap({\n        firstMin: startDate,\n        firstMax: endDate,\n        secondMin: secondMin,\n        secondMax: secondMax\n      })) {\n        return secondMin;\n      }\n    };\n\n    var startDateVerticalSearch = (() => {\n      var cellCount = groupData[0].length;\n\n      for (var cellIndex = 0; cellIndex < cellCount; ++cellIndex) {\n        for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n          var result = checkCellStartDate(rowIndex, cellIndex);\n\n          if (result) {\n            return result;\n          }\n        }\n      }\n    })();\n\n    var startDateHorizontalSearch = (() => {\n      for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n        var row = groupData[rowIndex];\n\n        for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {\n          var result = checkCellStartDate(rowIndex, cellIndex);\n\n          if (result) {\n            return result;\n          }\n        }\n      }\n    })();\n\n    return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch;\n  }\n\n  findAllDayGroupCellStartDate(groupIndex, startDate) {\n    var groupStartDate = this.getGroupStartDate(groupIndex);\n    return groupStartDate > startDate ? groupStartDate : startDate;\n  }\n\n  findCellPositionInMap(cellInfo) {\n    var {\n      groupIndex: groupIndex,\n      startDate: startDate,\n      isAllDay: isAllDay,\n      index: index\n    } = cellInfo;\n    var startTime = isAllDay ? dateUtils.trimTime(startDate).getTime() : startDate.getTime();\n\n    var isStartDateInCell = cellData => {\n      if (!this._workspace.isDateAndTimeView) {\n        return dateUtils.sameDate(startDate, cellData.startDate);\n      }\n\n      var cellStartTime = cellData.startDate.getTime();\n      var cellEndTime = cellData.endDate.getTime();\n      return isAllDay ? cellData.allDay && startTime >= cellStartTime && startTime <= cellEndTime : startTime >= cellStartTime && startTime < cellEndTime;\n    };\n\n    var {\n      allDayPanelGroupedMap: allDayPanelGroupedMap,\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var rows = isAllDay && !this._workspace._isVerticalGroupedWorkSpace() ? [allDayPanelGroupedMap[groupIndex]] || [] : dateTableGroupedMap[groupIndex] || [];\n\n    for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\n      var row = rows[rowIndex];\n\n      for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {\n        var cell = row[cellIndex];\n        var {\n          cellData: cellData\n        } = cell;\n\n        if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {\n          if (isStartDateInCell(cellData)) {\n            return cell.position;\n          }\n        }\n      }\n    }\n\n    return;\n  }\n\n  _isSameGroupIndexAndIndex(cellData, groupIndex, index) {\n    return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index);\n  }\n\n  getCellsGroup(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var groupData = dateTableGroupedMap[groupIndex];\n\n    if (groupData) {\n      var {\n        cellData: cellData\n      } = groupData[0][0];\n      return cellData.groups;\n    }\n  }\n\n  getCompletedGroupsInfo() {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    return dateTableGroupedMap.map(groupData => {\n      var firstCell = groupData[0][0];\n      var {\n        allDay: allDay,\n        groupIndex: groupIndex\n      } = firstCell.cellData;\n      return {\n        allDay: allDay,\n        groupIndex: groupIndex,\n        startDate: this.getGroupStartDate(groupIndex),\n        endDate: this.getGroupEndDate(groupIndex)\n      };\n    }).filter(_ref7 => {\n      var {\n        startDate: startDate\n      } = _ref7;\n      return !!startDate;\n    });\n  }\n\n  getGroupIndices() {\n    return this.getCompletedGroupsInfo().map(_ref8 => {\n      var {\n        groupIndex: groupIndex\n      } = _ref8;\n      return groupIndex;\n    });\n  }\n\n  getGroupFromDateTableGroupMap(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    return dateTableGroupedMap[groupIndex];\n  }\n\n  getFirstGroupRow(groupIndex) {\n    var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);\n\n    if (groupedData) {\n      var {\n        cellData: cellData\n      } = groupedData[0][0];\n      return !cellData.allDay ? groupedData[0] : groupedData[1];\n    }\n  }\n\n  getLastGroupRow(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var groupedData = dateTableGroupedMap[groupIndex];\n\n    if (groupedData) {\n      var lastRowIndex = groupedData.length - 1;\n      return groupedData[lastRowIndex];\n    }\n  }\n\n  getLastGroupCell(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var groupedRows = dateTableGroupedMap[groupIndex];\n    var lastRow = groupedRows[groupedRows.length - 1];\n    var result;\n\n    if (lastRow) {\n      var cellCount = lastRow.length;\n      result = lastRow[cellCount - 1];\n    }\n\n    return result;\n  }\n\n  getLastGroupCellPosition(groupIndex) {\n    var _groupCell;\n\n    var groupCell;\n\n    if (this.isVerticalGroupedWorkspace) {\n      var groupRow = this.getLastGroupRow(groupIndex);\n      groupCell = groupRow[groupRow.length - 1];\n    } else {\n      groupCell = this.getLastGroupCell(groupIndex);\n    }\n\n    return null === (_groupCell = groupCell) || void 0 === _groupCell ? void 0 : _groupCell.position;\n  }\n\n  getRowCountInGroup(groupIndex) {\n    var groupRow = this.getLastGroupRow(groupIndex);\n    var cellAmount = groupRow.length;\n    var lastCellData = groupRow[cellAmount - 1].cellData;\n    var lastCellIndex = lastCellData.index;\n    return (lastCellIndex + 1) / groupRow.length;\n  }\n\n}\n\nexport default class ViewDataProvider {\n  constructor(workspace) {\n    this._viewDataGenerator = null;\n    this._viewData = [];\n    this._completeViewDataMap = [];\n    this._completeDateHeaderMap = [];\n    this._viewDataMap = [];\n    this._groupedDataMapProvider = null;\n    this._workspace = workspace;\n  }\n\n  get viewDataGenerator() {\n    if (!this._viewDataGenerator) {\n      this._viewDataGenerator = new ViewDataGenerator(this._workspace);\n    }\n\n    return this._viewDataGenerator;\n  }\n\n  get completeViewDataMap() {\n    return this._completeViewDataMap;\n  }\n\n  set completeViewDataMap(value) {\n    this._completeViewDataMap = value;\n  }\n\n  get completeDateHeaderMap() {\n    return this._completeDateHeaderMap;\n  }\n\n  set completeDateHeaderMap(value) {\n    this._completeDateHeaderMap = value;\n  }\n\n  get completeTimePanelMap() {\n    return this._completeTimePanelMap;\n  }\n\n  set completeTimePanelMap(value) {\n    this._completeTimePanelMap = value;\n  }\n\n  get viewData() {\n    return this._viewData;\n  }\n\n  set viewData(value) {\n    this._viewData = value;\n  }\n\n  get viewDataMap() {\n    return this._viewDataMap;\n  }\n\n  set viewDataMap(value) {\n    this._viewDataMap = value;\n  }\n\n  get dateHeaderData() {\n    return this._dateHeaderData;\n  }\n\n  set dateHeaderData(value) {\n    this._dateHeaderData = value;\n  }\n\n  get timePanelData() {\n    return this._timePanelData;\n  }\n\n  set timePanelData(value) {\n    this._timePanelData = value;\n  }\n\n  get groupedDataMap() {\n    return this._groupedDataMapProvider.groupedDataMap;\n  }\n\n  get isVerticalGroupedWorkspace() {\n    return this._workspace._isVerticalGroupedWorkSpace();\n  }\n\n  update(isGenerateNewViewData) {\n    var {\n      viewDataGenerator: viewDataGenerator,\n      _workspace: _workspace\n    } = this;\n\n    var renderOptions = _workspace.generateRenderOptions();\n\n    if (isGenerateNewViewData) {\n      this.completeViewDataMap = viewDataGenerator._getCompleteViewDataMap(renderOptions);\n      this.completeDateHeaderMap = viewDataGenerator._getCompleteDateHeaderMap(renderOptions, this.completeViewDataMap);\n      this.completeTimePanelMap = viewDataGenerator._getCompleteTimePanelMap(renderOptions, this.completeViewDataMap);\n    }\n\n    this.viewDataMap = viewDataGenerator._generateViewDataMap(this.completeViewDataMap, renderOptions);\n    this.viewData = viewDataGenerator._getViewDataFromMap(this.viewDataMap, renderOptions);\n    this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, this._workspace);\n    this.dateHeaderData = viewDataGenerator._generateDateHeaderData(this.completeDateHeaderMap, renderOptions);\n    this.timePanelData = viewDataGenerator._generateTimePanelData(this.completeTimePanelMap, renderOptions);\n  }\n\n  getStartDate() {\n    var {\n      groupedData: groupedData\n    } = this.viewData;\n    var {\n      dateTable: dateTable\n    } = groupedData[0];\n    return dateTable[0][0].startDate;\n  }\n\n  getGroupStartDate(groupIndex) {\n    return this._groupedDataMapProvider.getGroupStartDate(groupIndex);\n  }\n\n  getGroupEndDate(groupIndex) {\n    return this._groupedDataMapProvider.getGroupEndDate(groupIndex);\n  }\n\n  findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay) {\n    return this._groupedDataMapProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay);\n  }\n\n  findAllDayGroupCellStartDate(groupIndex, startDate) {\n    return this._groupedDataMapProvider.findAllDayGroupCellStartDate(groupIndex, startDate);\n  }\n\n  findCellPositionInMap(cellInfo) {\n    return this._groupedDataMapProvider.findCellPositionInMap(cellInfo);\n  }\n\n  getCellsGroup(groupIndex) {\n    return this._groupedDataMapProvider.getCellsGroup(groupIndex);\n  }\n\n  getCompletedGroupsInfo() {\n    return this._groupedDataMapProvider.getCompletedGroupsInfo();\n  }\n\n  getGroupIndices() {\n    return this._groupedDataMapProvider.getGroupIndices();\n  }\n\n  getLastGroupCellPosition(groupIndex) {\n    return this._groupedDataMapProvider.getLastGroupCellPosition(groupIndex);\n  }\n\n  getRowCountInGroup(groupIndex) {\n    return this._groupedDataMapProvider.getRowCountInGroup(groupIndex);\n  }\n\n  getCellData(rowIndex, cellIndex, isAllDay) {\n    if (isAllDay && !this.isVerticalGroupedWorkspace) {\n      return this._viewData.groupedData[0].allDayPanel[cellIndex];\n    }\n\n    var {\n      dateTableMap: dateTableMap\n    } = this.viewDataMap;\n    var {\n      cellData: cellData\n    } = dateTableMap[rowIndex][cellIndex];\n    return cellData;\n  }\n\n  getCellsByGroupIndexAndAllDay(groupIndex, allDay) {\n    var workspace = this._workspace;\n\n    var rowsPerGroup = workspace._getRowCountWithAllDayRows();\n\n    var isShowAllDayPanel = workspace.isAllDayPanelVisible;\n    var firstRowInGroup = this.isVerticalGroupedWorkspace ? groupIndex * rowsPerGroup : 0;\n    var lastRowInGroup = this.isVerticalGroupedWorkspace ? (groupIndex + 1) * rowsPerGroup - 1 : rowsPerGroup;\n    var correctedFirstRow = isShowAllDayPanel && !allDay ? firstRowInGroup + 1 : firstRowInGroup;\n    var correctedLastRow = allDay ? correctedFirstRow : lastRowInGroup;\n    return this.completeViewDataMap.slice(correctedFirstRow, correctedLastRow + 1).map(row => row.filter(_ref9 => {\n      var {\n        groupIndex: currentGroupIndex\n      } = _ref9;\n      return groupIndex === currentGroupIndex;\n    }));\n  }\n\n  getGroupData(groupIndex) {\n    var {\n      groupedData: groupedData\n    } = this.viewData;\n\n    if (this.isVerticalGroupedWorkspace) {\n      return groupedData.filter(item => item.groupIndex === groupIndex)[0];\n    }\n\n    var filterCells = row => null === row || void 0 === row ? void 0 : row.filter(cell => cell.groupIndex === groupIndex);\n\n    var {\n      allDayPanel: allDayPanel,\n      dateTable: dateTable\n    } = groupedData[0];\n    var filteredDateTable = [];\n    dateTable.forEach(row => {\n      filteredDateTable.push(filterCells(row));\n    });\n    return {\n      allDayPanel: filterCells(allDayPanel),\n      dateTable: filteredDateTable\n    };\n  }\n\n  getCellCountWithGroup(groupIndex) {\n    var rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    return dateTableGroupedMap.filter((_, index) => index <= groupIndex).reduce((previous, row) => previous + row[rowIndex].length, 0);\n  }\n\n  getAllDayPanel(groupIndex) {\n    var groupData = this.getGroupData(groupIndex);\n    return null === groupData || void 0 === groupData ? void 0 : groupData.allDayPanel;\n  }\n\n  isGroupIntersectDateInterval(groupIndex, startDate, endDate) {\n    var groupStartDate = this.getGroupStartDate(groupIndex);\n    var groupEndDate = this.getGroupEndDate(groupIndex);\n    return startDate < groupEndDate && endDate > groupStartDate;\n  }\n\n  findGlobalCellPosition(date) {\n    var groupIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n    var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n    var {\n      completeViewDataMap: completeViewDataMap,\n      _workspace: workspace\n    } = this;\n    var showAllDayPanel = workspace.isAllDayPanelVisible;\n\n    for (var rowIndex = 0; rowIndex < completeViewDataMap.length; rowIndex += 1) {\n      var currentRow = completeViewDataMap[rowIndex];\n\n      for (var columnIndex = 0; columnIndex < currentRow.length; columnIndex += 1) {\n        var cellData = currentRow[columnIndex];\n        var {\n          startDate: currentStartDate,\n          endDate: currentEndDate,\n          groupIndex: currentGroupIndex,\n          allDay: currentAllDay\n        } = cellData;\n\n        if (groupIndex === currentGroupIndex && allDay === !!currentAllDay && this._compareDatesAndAllDay(date, currentStartDate, currentEndDate, allDay)) {\n          return {\n            position: {\n              columnIndex: columnIndex,\n              rowIndex: showAllDayPanel && !this.isVerticalGroupedWorkspace ? rowIndex - 1 : rowIndex\n            },\n            cellData: cellData\n          };\n        }\n      }\n    }\n  }\n\n  _compareDatesAndAllDay(date, cellStartDate, cellEndDate, allDay) {\n    var time = date.getTime();\n    var trimmedTime = dateUtils.trimTime(date).getTime();\n    var cellStartTime = cellStartDate.getTime();\n    var cellEndTime = cellEndDate.getTime();\n    return !allDay && time >= cellStartTime && time < cellEndTime || allDay && trimmedTime === cellStartTime;\n  }\n\n  getSkippedDaysCount(groupIndex, startDate, endDate, daysCount) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this._groupedDataMapProvider.groupedDataMap;\n    var groupedData = dateTableGroupedMap[groupIndex];\n    var includedDays = 0;\n\n    for (var rowIndex = 0; rowIndex < groupedData.length; rowIndex += 1) {\n      for (var columnIndex = 0; columnIndex < groupedData[rowIndex].length; columnIndex += 1) {\n        var cell = groupedData[rowIndex][columnIndex].cellData;\n\n        if (startDate.getTime() < cell.endDate.getTime() && endDate.getTime() > cell.startDate.getTime()) {\n          includedDays += 1;\n        }\n      }\n    }\n\n    var lastCell = groupedData[groupedData.length - 1][groupedData[0].length - 1].cellData;\n    var lastCellStart = dateUtils.trimTime(lastCell.startDate);\n    var daysAfterView = Math.floor((endDate.getTime() - lastCellStart.getTime()) / dateUtils.dateToMilliseconds(\"day\"));\n    var deltaDays = daysAfterView > 0 ? daysAfterView : 0;\n    return daysCount - includedDays - deltaDays;\n  }\n\n}","map":{"version":3,"sources":["/home/igor/node_modules/devextreme/esm/ui/scheduler/workspaces/view_data_provider.js"],"names":["_objectWithoutPropertiesLoose","_extends","_excluded","_excluded2","dateUtils","HORIZONTAL_GROUP_ORIENTATION","ViewDataGenerator","constructor","workspace","_workspace","value","isVerticalGroupedWorkspace","_isVerticalGroupedWorkSpace","isStandaloneAllDayPanel","isAllDayPanelVisible","_getCompleteViewDataMap","options","rowCountInGroup","cellCountInGroupRow","groupsList","groupByDate","isHorizontalGrouping","isVerticalGrouping","totalCellCount","groupCount","viewDataMap","step","allDayPanelData","_generateAllDayPanelData","viewCellsData","_generateViewCellsData","push","_transformViewDataMapForHorizontalGrouping","_transformViewDataMapForVerticalGrouping","_transformViewDataMapForGroupingByDate","completeViewDataMap","_addKeysToCells","result","map","row","slice","forEach","groups","index","groupIndex","rowIndex","nextGroupRow","cellData","nextGroupMap","cellsRow","nextRow","correctedGroupList","correctedGroupCount","length","groupedByDateCellsRow","reduce","currentRow","cell","rowWithCurrentCell","isFirstGroupCell","isLastGroupCell","totalColumnCount","currentViewDataMap","_ref","allDayPanelsCount","isAllDay","allDay","keyBase","currentAllDayPanelsCount","cellIndex","key","_getCompleteDateHeaderMap","isGenerateWeekDaysHeaderData","weekDaysRow","_generateWeekDaysHeaderRowMap","dateRow","_generateHeaderDateRow","horizontalGroupCount","cellCountInDay","getWeekDaysHeaderText","daysInView","colSpan","dayIndex","text","startDate","getDateHeaderText","today","groupOrientation","getDateHeaderDate","dates","dateIndex","slicedByColumnsData","filter","_","columnIndex","_ref2","restProps","sameDate","_getCompleteTimePanelMap","getTimeCellDate","times","allDayRowsCount","_row$","restCellProps","timeIndex","_generateViewDataMap","rowCount","startCellIndex","cellCount","startRowIndex","sliceCells","startIndex","count","position","correctedStartRowIndex","allDayPanelMap","dateTableMap","_generateDateHeaderData","completeDateHeaderMap","cellWidth","isProvideVirtualCellsWidth","dataMap","weekDayRowConfig","validCellWidth","_generateDateHeaderDataRow","datesRowConfig","leftVirtualCellWidth","rightVirtualCellWidth","leftVirtualCellCount","rightVirtualCellCount","weekDayLeftVirtualCellWidth","weekDayRightVirtualCellWidth","weekDayLeftVirtualCellCount","weekDayRightVirtualCellCount","baseColSpan","Math","floor","actualCellCount","ceil","finalLeftVirtualCellCount","finalLeftVirtualCellWidth","finalRightVirtualCellCount","finalRightVirtualCellWidth","_generateTimePanelData","completeTimePanelMap","topVirtualRowHeight","bottomVirtualRowHeight","isGroupedAllDayPanel","showAllDayPanel","indexDifference","timePanelMap","timePanelData","previousGroupedData","groupedData","_generateTimePanelDataFromMap","_ref3","previousGroupIndex","currentGroupIndex","dateTable","allDayPanel","_getViewDataFromMap","totalRowCount","_ref4","cellDataRow","_ref5","firstCell","isAllDayRow","_ref6","topVirtualRowCount","bottomVirtualRowCount","rowsCount","arguments","cellDataGetters","_generateCellsRow","workSpace","_getAllDayCellData","bind","columnCount","_this","_loop","correctedColumnIndex","cellDataValue","data","getter","_isFirstGroupCell","_isLastGroupCell","_calculateCellIndex","isGroupedByDate","columnsNumber","columnsInGroup","columnIndexInCurrentGroup","generateGroupedDataMap","previousGroupedDataMap","dateTableGroupedMap","previousOptions","previousRowIndex","currentRowIndex","allDayPanelGroupedMap","GroupedDataMapProvider","viewDataGenerator","groupedDataMap","getGroupStartDate","firstRow","getFirstGroupRow","getGroupEndDate","lastRow","getLastGroupRow","lastCellIndex","endDate","findGroupCellStartDate","findAllDayGroupCellStartDate","groupData","getGroupFromDateTableGroupMap","checkCellStartDate","secondMin","secondMax","intervalsOverlap","firstMin","firstMax","startDateVerticalSearch","startDateHorizontalSearch","groupStartDate","findCellPositionInMap","cellInfo","startTime","trimTime","getTime","isStartDateInCell","isDateAndTimeView","cellStartTime","cellEndTime","rows","_isSameGroupIndexAndIndex","getCellsGroup","getCompletedGroupsInfo","_ref7","getGroupIndices","_ref8","lastRowIndex","getLastGroupCell","groupedRows","getLastGroupCellPosition","_groupCell","groupCell","groupRow","getRowCountInGroup","cellAmount","lastCellData","ViewDataProvider","_viewDataGenerator","_viewData","_completeViewDataMap","_completeDateHeaderMap","_viewDataMap","_groupedDataMapProvider","_completeTimePanelMap","viewData","dateHeaderData","_dateHeaderData","_timePanelData","update","isGenerateNewViewData","renderOptions","generateRenderOptions","getStartDate","getCellData","getCellsByGroupIndexAndAllDay","rowsPerGroup","_getRowCountWithAllDayRows","isShowAllDayPanel","firstRowInGroup","lastRowInGroup","correctedFirstRow","correctedLastRow","_ref9","getGroupData","item","filterCells","filteredDateTable","getCellCountWithGroup","previous","getAllDayPanel","isGroupIntersectDateInterval","groupEndDate","findGlobalCellPosition","date","currentStartDate","currentEndDate","currentAllDay","_compareDatesAndAllDay","cellStartDate","cellEndDate","time","trimmedTime","getSkippedDaysCount","daysCount","includedDays","lastCell","lastCellStart","daysAfterView","dateToMilliseconds","deltaDays"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_data_provider.js)\r\n * Version: 21.1.6\r\n * Build date: Mon Sep 27 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nvar _excluded = [\"startDate\", \"endDate\", \"isFirstGroupCell\", \"isLastGroupCell\"],\r\n    _excluded2 = [\"allDay\", \"startDate\", \"endDate\"];\r\nimport dateUtils from \"../../../core/utils/date\";\r\nimport {\r\n    HORIZONTAL_GROUP_ORIENTATION\r\n} from \"../constants\";\r\nclass ViewDataGenerator {\r\n    constructor(workspace) {\r\n        this.workspace = workspace\r\n    }\r\n    get workspace() {\r\n        return this._workspace\r\n    }\r\n    set workspace(value) {\r\n        this._workspace = value\r\n    }\r\n    get isVerticalGroupedWorkspace() {\r\n        return this.workspace._isVerticalGroupedWorkSpace()\r\n    }\r\n    get isStandaloneAllDayPanel() {\r\n        return !this.isVerticalGroupedWorkspace && this.workspace.isAllDayPanelVisible\r\n    }\r\n    _getCompleteViewDataMap(options) {\r\n        var {\r\n            rowCountInGroup: rowCountInGroup,\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            groupsList: groupsList,\r\n            groupByDate: groupByDate,\r\n            isHorizontalGrouping: isHorizontalGrouping,\r\n            isVerticalGrouping: isVerticalGrouping,\r\n            totalCellCount: totalCellCount,\r\n            groupCount: groupCount\r\n        } = options;\r\n        var viewDataMap = [];\r\n        var step = groupByDate ? groupCount : 1;\r\n        var allDayPanelData = this._generateAllDayPanelData(options, cellCountInGroupRow, step);\r\n        var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, step);\r\n        allDayPanelData && viewDataMap.push(allDayPanelData);\r\n        viewDataMap.push(...viewCellsData);\r\n        if (isHorizontalGrouping && !groupByDate) {\r\n            viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList)\r\n        }\r\n        if (isVerticalGrouping) {\r\n            viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList)\r\n        }\r\n        if (groupByDate) {\r\n            viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList)\r\n        }\r\n        var completeViewDataMap = this._addKeysToCells(viewDataMap, totalCellCount);\r\n        return completeViewDataMap\r\n    }\r\n    _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\r\n        var result = viewDataMap.map(row => row.slice());\r\n        groupsList.slice(1).forEach((groups, index) => {\r\n            var groupIndex = index + 1;\r\n            viewDataMap.forEach((row, rowIndex) => {\r\n                var nextGroupRow = row.map(cellData => _extends({}, cellData, {\r\n                    groups: groups,\r\n                    groupIndex: groupIndex\r\n                }));\r\n                result[rowIndex].push(...nextGroupRow)\r\n            })\r\n        });\r\n        return result\r\n    }\r\n    _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\r\n        var result = viewDataMap.map(row => row.slice());\r\n        groupsList.slice(1).forEach((groups, index) => {\r\n            var groupIndex = index + 1;\r\n            var nextGroupMap = viewDataMap.map(cellsRow => {\r\n                var nextRow = cellsRow.map(cellData => _extends({}, cellData, {\r\n                    groupIndex: groupIndex,\r\n                    groups: groups\r\n                }));\r\n                return nextRow\r\n            });\r\n            result.push(...nextGroupMap)\r\n        });\r\n        return result\r\n    }\r\n    _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\r\n        var correctedGroupList = groupsList.slice(1);\r\n        var correctedGroupCount = correctedGroupList.length;\r\n        var result = viewDataMap.map(cellsRow => {\r\n            var groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {\r\n                var rowWithCurrentCell = [...currentRow, _extends({}, cell, {\r\n                    isFirstGroupCell: true,\r\n                    isLastGroupCell: 0 === correctedGroupCount\r\n                }), ...correctedGroupList.map((groups, index) => _extends({}, cell, {\r\n                    groups: groups,\r\n                    groupIndex: index + 1,\r\n                    isFirstGroupCell: false,\r\n                    isLastGroupCell: index === correctedGroupCount - 1\r\n                }))];\r\n                return rowWithCurrentCell\r\n            }, []);\r\n            return groupedByDateCellsRow\r\n        });\r\n        return result\r\n    }\r\n    _addKeysToCells(viewDataMap, totalColumnCount) {\r\n        var {\r\n            currentViewDataMap: result\r\n        } = viewDataMap.reduce((_ref, row, rowIndex) => {\r\n            var {\r\n                allDayPanelsCount: allDayPanelsCount,\r\n                currentViewDataMap: currentViewDataMap\r\n            } = _ref;\r\n            var isAllDay = row[0].allDay;\r\n            var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\r\n            var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\r\n            currentViewDataMap[rowIndex].forEach((cell, cellIndex) => {\r\n                cell.key = keyBase + cellIndex\r\n            });\r\n            return {\r\n                allDayPanelsCount: currentAllDayPanelsCount,\r\n                currentViewDataMap: currentViewDataMap\r\n            }\r\n        }, {\r\n            allDayPanelsCount: 0,\r\n            currentViewDataMap: viewDataMap\r\n        });\r\n        return result\r\n    }\r\n    _getCompleteDateHeaderMap(options, completeViewDataMap) {\r\n        var {\r\n            isGenerateWeekDaysHeaderData: isGenerateWeekDaysHeaderData\r\n        } = options;\r\n        var result = [];\r\n        if (isGenerateWeekDaysHeaderData) {\r\n            var weekDaysRow = this._generateWeekDaysHeaderRowMap(options, completeViewDataMap);\r\n            result.push(weekDaysRow)\r\n        }\r\n        var dateRow = this._generateHeaderDateRow(options, completeViewDataMap);\r\n        result.push(dateRow);\r\n        return result\r\n    }\r\n    _generateWeekDaysHeaderRowMap(options, completeViewDataMap) {\r\n        var {\r\n            groupByDate: groupByDate,\r\n            horizontalGroupCount: horizontalGroupCount,\r\n            cellCountInDay: cellCountInDay,\r\n            getWeekDaysHeaderText: getWeekDaysHeaderText,\r\n            daysInView: daysInView\r\n        } = options;\r\n        var index = completeViewDataMap[0][0].allDay ? 1 : 0;\r\n        var colSpan = groupByDate ? horizontalGroupCount * cellCountInDay : cellCountInDay;\r\n        var weekDaysRow = [];\r\n        for (var dayIndex = 0; dayIndex < daysInView; dayIndex += 1) {\r\n            var cell = completeViewDataMap[index][dayIndex * colSpan];\r\n            weekDaysRow.push(_extends({}, cell, {\r\n                colSpan: colSpan,\r\n                text: getWeekDaysHeaderText(cell.startDate),\r\n                isFirstGroupCell: false,\r\n                isLastGroupCell: false\r\n            }))\r\n        }\r\n        return weekDaysRow\r\n    }\r\n    _generateHeaderDateRow(options, completeViewDataMap) {\r\n        var {\r\n            getDateHeaderText: getDateHeaderText,\r\n            today: today,\r\n            groupByDate: groupByDate,\r\n            horizontalGroupCount: horizontalGroupCount,\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            groupOrientation: groupOrientation,\r\n            getDateHeaderDate: getDateHeaderDate\r\n        } = options;\r\n        var dates = [];\r\n        for (var dateIndex = 0; dateIndex < cellCountInGroupRow; dateIndex += 1) {\r\n            dates.push(getDateHeaderDate(dateIndex))\r\n        }\r\n        var index = completeViewDataMap[0][0].allDay ? 1 : 0;\r\n        var colSpan = groupByDate ? horizontalGroupCount : 1;\r\n        var isVerticalGrouping = \"vertical\" === groupOrientation;\r\n        var slicedByColumnsData = groupByDate ? completeViewDataMap[index].filter((_, columnIndex) => columnIndex % horizontalGroupCount === 0) : completeViewDataMap[index];\r\n        return slicedByColumnsData.map((_ref2, index) => {\r\n            var {\r\n                startDate: startDate,\r\n                isFirstGroupCell: isFirstGroupCell,\r\n                isLastGroupCell: isLastGroupCell\r\n            } = _ref2, restProps = _objectWithoutPropertiesLoose(_ref2, _excluded);\r\n            return _extends({}, restProps, {\r\n                startDate: dates[index % cellCountInGroupRow],\r\n                text: getDateHeaderText(index % cellCountInGroupRow),\r\n                today: dateUtils.sameDate(startDate, today),\r\n                colSpan: colSpan,\r\n                isFirstGroupCell: groupByDate || isFirstGroupCell && !isVerticalGrouping,\r\n                isLastGroupCell: groupByDate || isLastGroupCell && !isVerticalGrouping\r\n            })\r\n        })\r\n    }\r\n    _getCompleteTimePanelMap(options, completeViewDataMap) {\r\n        var {\r\n            rowCountInGroup: rowCountInGroup,\r\n            getTimeCellDate: getTimeCellDate\r\n        } = options;\r\n        var times = [];\r\n        for (var rowIndex = 0; rowIndex < rowCountInGroup; rowIndex += 1) {\r\n            times.push(getTimeCellDate(rowIndex))\r\n        }\r\n        var allDayRowsCount = 0;\r\n        return completeViewDataMap.map((row, index) => {\r\n            var _row$ = row[0],\r\n                {\r\n                    allDay: allDay,\r\n                    startDate: startDate\r\n                } = _row$,\r\n                restCellProps = _objectWithoutPropertiesLoose(_row$, _excluded2);\r\n            if (allDay) {\r\n                allDayRowsCount += 1\r\n            }\r\n            var timeIndex = (index - allDayRowsCount) % rowCountInGroup;\r\n            return _extends({}, restCellProps, {\r\n                allDay: allDay,\r\n                startDate: allDay ? startDate : times[timeIndex]\r\n            })\r\n        })\r\n    }\r\n    _generateViewDataMap(completeViewDataMap, options) {\r\n        var {\r\n            rowCount: rowCount,\r\n            startCellIndex: startCellIndex,\r\n            cellCount: cellCount\r\n        } = options;\r\n        var {\r\n            startRowIndex: startRowIndex\r\n        } = options;\r\n        var sliceCells = (row, rowIndex, startIndex, count) => row.slice(startIndex, startIndex + count).map((cellData, cellIndex) => ({\r\n            cellData: cellData,\r\n            position: {\r\n                rowIndex: rowIndex,\r\n                cellIndex: cellIndex\r\n            }\r\n        }));\r\n        var correctedStartRowIndex = startRowIndex;\r\n        var allDayPanelMap = [];\r\n        if (this.isStandaloneAllDayPanel) {\r\n            correctedStartRowIndex++;\r\n            allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount)\r\n        }\r\n        var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + rowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));\r\n        return {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        }\r\n    }\r\n    _generateDateHeaderData(completeDateHeaderMap, options) {\r\n        var {\r\n            isGenerateWeekDaysHeaderData: isGenerateWeekDaysHeaderData,\r\n            cellCountInDay: cellCountInDay,\r\n            cellWidth: cellWidth,\r\n            isProvideVirtualCellsWidth: isProvideVirtualCellsWidth\r\n        } = options;\r\n        var dataMap = [];\r\n        var weekDayRowConfig = {};\r\n        var validCellWidth = cellWidth || 0;\r\n        if (isGenerateWeekDaysHeaderData) {\r\n            weekDayRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, cellCountInDay, 0, validCellWidth);\r\n            dataMap.push(weekDayRowConfig.dateRow)\r\n        }\r\n        var datesRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, 1, isGenerateWeekDaysHeaderData ? 1 : 0, validCellWidth);\r\n        dataMap.push(datesRowConfig.dateRow);\r\n        return {\r\n            dataMap: dataMap,\r\n            leftVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.leftVirtualCellWidth : void 0,\r\n            rightVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.rightVirtualCellWidth : void 0,\r\n            leftVirtualCellCount: datesRowConfig.leftVirtualCellCount,\r\n            rightVirtualCellCount: datesRowConfig.rightVirtualCellCount,\r\n            weekDayLeftVirtualCellWidth: weekDayRowConfig.leftVirtualCellWidth,\r\n            weekDayRightVirtualCellWidth: weekDayRowConfig.rightVirtualCellWidth,\r\n            weekDayLeftVirtualCellCount: weekDayRowConfig.leftVirtualCellCount,\r\n            weekDayRightVirtualCellCount: weekDayRowConfig.rightVirtualCellCount\r\n        }\r\n    }\r\n    _generateDateHeaderDataRow(options, completeDateHeaderMap, baseColSpan, rowIndex, cellWidth) {\r\n        var {\r\n            groupByDate: groupByDate,\r\n            horizontalGroupCount: horizontalGroupCount,\r\n            startCellIndex: startCellIndex,\r\n            cellCount: cellCount,\r\n            totalCellCount: totalCellCount,\r\n            isProvideVirtualCellsWidth: isProvideVirtualCellsWidth\r\n        } = options;\r\n        var colSpan = groupByDate ? horizontalGroupCount * baseColSpan : baseColSpan;\r\n        var leftVirtualCellCount = Math.floor(startCellIndex / colSpan);\r\n        var actualCellCount = Math.ceil((startCellIndex + cellCount) / colSpan);\r\n        var dateRow = completeDateHeaderMap[rowIndex].slice(leftVirtualCellCount, actualCellCount);\r\n        var finalLeftVirtualCellCount = leftVirtualCellCount * colSpan;\r\n        var finalLeftVirtualCellWidth = finalLeftVirtualCellCount * cellWidth;\r\n        var finalRightVirtualCellCount = totalCellCount - actualCellCount * colSpan;\r\n        var finalRightVirtualCellWidth = finalRightVirtualCellCount * cellWidth;\r\n        return {\r\n            dateRow: dateRow,\r\n            leftVirtualCellCount: finalLeftVirtualCellCount,\r\n            leftVirtualCellWidth: isProvideVirtualCellsWidth ? finalLeftVirtualCellWidth : void 0,\r\n            rightVirtualCellCount: finalRightVirtualCellCount,\r\n            rightVirtualCellWidth: isProvideVirtualCellsWidth ? finalRightVirtualCellWidth : void 0\r\n        }\r\n    }\r\n    _generateTimePanelData(completeTimePanelMap, options) {\r\n        var {\r\n            startRowIndex: startRowIndex,\r\n            rowCount: rowCount,\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            cellCountInGroupRow: cellCountInGroupRow\r\n        } = options;\r\n        var isGroupedAllDayPanel = this.workspace.isGroupedAllDayPanel();\r\n        var showAllDayPanel = this.workspace.isAllDayPanelVisible;\r\n        var indexDifference = this.isVerticalGroupedWorkspace || !showAllDayPanel ? 0 : 1;\r\n        var correctedStartRowIndex = startRowIndex + indexDifference;\r\n        var timePanelMap = completeTimePanelMap.slice(correctedStartRowIndex, correctedStartRowIndex + rowCount);\r\n        var timePanelData = {\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n            cellCountInGroupRow: cellCountInGroupRow\r\n        };\r\n        var {\r\n            previousGroupedData: groupedData\r\n        } = this._generateTimePanelDataFromMap(timePanelMap, isGroupedAllDayPanel);\r\n        timePanelData.groupedData = groupedData;\r\n        return timePanelData\r\n    }\r\n    _generateTimePanelDataFromMap(timePanelMap, isGroupedAllDayPanel) {\r\n        return timePanelMap.reduce((_ref3, cellData) => {\r\n            var {\r\n                previousGroupIndex: previousGroupIndex,\r\n                previousGroupedData: previousGroupedData\r\n            } = _ref3;\r\n            var currentGroupIndex = cellData.groupIndex;\r\n            if (currentGroupIndex !== previousGroupIndex) {\r\n                previousGroupedData.push({\r\n                    dateTable: [],\r\n                    isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n                    groupIndex: currentGroupIndex\r\n                })\r\n            }\r\n            if (cellData.allDay) {\r\n                previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellData\r\n            } else {\r\n                previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellData)\r\n            }\r\n            return {\r\n                previousGroupIndex: currentGroupIndex,\r\n                previousGroupedData: previousGroupedData\r\n            }\r\n        }, {\r\n            previousGroupIndex: -1,\r\n            previousGroupedData: []\r\n        })\r\n    }\r\n    _getViewDataFromMap(viewDataMap, options) {\r\n        var {\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            leftVirtualCellWidth: leftVirtualCellWidth,\r\n            rightVirtualCellWidth: rightVirtualCellWidth,\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            totalCellCount: totalCellCount,\r\n            totalRowCount: totalRowCount,\r\n            cellCount: cellCount,\r\n            rowCount: rowCount,\r\n            startRowIndex: startRowIndex,\r\n            startCellIndex: startCellIndex,\r\n            isProvideVirtualCellsWidth: isProvideVirtualCellsWidth\r\n        } = options;\r\n        var isGroupedAllDayPanel = this.workspace.isGroupedAllDayPanel();\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var {\r\n            previousGroupedData: groupedData\r\n        } = dateTableMap.reduce((_ref4, cellsRow) => {\r\n            var {\r\n                previousGroupIndex: previousGroupIndex,\r\n                previousGroupedData: previousGroupedData\r\n            } = _ref4;\r\n            var cellDataRow = cellsRow.map(_ref5 => {\r\n                var {\r\n                    cellData: cellData\r\n                } = _ref5;\r\n                return cellData\r\n            });\r\n            var firstCell = cellDataRow[0];\r\n            var isAllDayRow = firstCell.allDay;\r\n            var currentGroupIndex = firstCell.groupIndex;\r\n            if (currentGroupIndex !== previousGroupIndex) {\r\n                previousGroupedData.push({\r\n                    dateTable: [],\r\n                    isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n                    groupIndex: currentGroupIndex\r\n                })\r\n            }\r\n            if (isAllDayRow) {\r\n                previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellDataRow\r\n            } else {\r\n                previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellDataRow)\r\n            }\r\n            return {\r\n                previousGroupedData: previousGroupedData,\r\n                previousGroupIndex: currentGroupIndex\r\n            }\r\n        }, {\r\n            previousGroupIndex: -1,\r\n            previousGroupedData: []\r\n        });\r\n        if (this.isStandaloneAllDayPanel) {\r\n            groupedData[0].allDayPanel = allDayPanelMap.map(_ref6 => {\r\n                var {\r\n                    cellData: cellData\r\n                } = _ref6;\r\n                return cellData\r\n            })\r\n        }\r\n        return {\r\n            groupedData: groupedData,\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\r\n            rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n            leftVirtualCellCount: startCellIndex,\r\n            rightVirtualCellCount: totalCellCount - startCellIndex - cellCount,\r\n            topVirtualRowCount: startRowIndex,\r\n            bottomVirtualRowCount: totalRowCount - startRowIndex - rowCount\r\n        }\r\n    }\r\n    _generateViewCellsData(options, rowsCount) {\r\n        var step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\r\n        var {\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            cellDataGetters: cellDataGetters\r\n        } = options;\r\n        var viewCellsData = [];\r\n        for (var rowIndex = 0; rowIndex < rowsCount; rowIndex += 1) {\r\n            viewCellsData.push(this._generateCellsRow(options, cellDataGetters, rowIndex, cellCountInGroupRow, step))\r\n        }\r\n        return viewCellsData\r\n    }\r\n    _generateAllDayPanelData(options, cellCount) {\r\n        var step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\r\n        var workSpace = this.workspace;\r\n        if (!workSpace.isAllDayPanelVisible) {\r\n            return null\r\n        }\r\n        return this._generateCellsRow(options, [workSpace._getAllDayCellData.bind(workSpace)], 0, cellCount, step)\r\n    }\r\n    _generateCellsRow(options, cellDataGetters, rowIndex, columnCount, step) {\r\n        var _this = this;\r\n        var cellsRow = [];\r\n        var _loop = function(columnIndex) {\r\n            var correctedColumnIndex = step * columnIndex;\r\n            var cellDataValue = cellDataGetters.reduce((data, getter) => _extends({}, data, getter(void 0, rowIndex, correctedColumnIndex, 0, data.startDate).value), {});\r\n            cellDataValue.index = rowIndex * columnCount + columnIndex;\r\n            cellDataValue.isFirstGroupCell = _this._isFirstGroupCell(rowIndex, columnIndex, options);\r\n            cellDataValue.isLastGroupCell = _this._isLastGroupCell(rowIndex, columnIndex, options);\r\n            cellsRow.push(cellDataValue)\r\n        };\r\n        for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\r\n            _loop(columnIndex)\r\n        }\r\n        return cellsRow\r\n    }\r\n    _calculateCellIndex(horizontalGroupCount, groupOrientation, isGroupedByDate, rowIndex, columnIndex, columnsNumber) {\r\n        var groupCount = horizontalGroupCount || 1;\r\n        var index = rowIndex * columnsNumber + columnIndex;\r\n        var columnsInGroup = columnsNumber / groupCount;\r\n        if (\"horizontal\" === groupOrientation) {\r\n            var columnIndexInCurrentGroup = columnIndex % columnsInGroup;\r\n            if (isGroupedByDate) {\r\n                columnIndexInCurrentGroup = Math.floor(columnIndex / groupCount)\r\n            }\r\n            index = rowIndex * columnsInGroup + columnIndexInCurrentGroup\r\n        }\r\n        return index\r\n    }\r\n    generateGroupedDataMap(viewDataMap) {\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var {\r\n            previousGroupedDataMap: dateTableGroupedMap\r\n        } = dateTableMap.reduce((previousOptions, cellsRow) => {\r\n            var {\r\n                previousGroupedDataMap: previousGroupedDataMap,\r\n                previousRowIndex: previousRowIndex,\r\n                previousGroupIndex: previousGroupIndex\r\n            } = previousOptions;\r\n            var {\r\n                groupIndex: currentGroupIndex\r\n            } = cellsRow[0].cellData;\r\n            var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\r\n            cellsRow.forEach(cell => {\r\n                var {\r\n                    groupIndex: groupIndex\r\n                } = cell.cellData;\r\n                if (!previousGroupedDataMap[groupIndex]) {\r\n                    previousGroupedDataMap[groupIndex] = []\r\n                }\r\n                if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\r\n                    previousGroupedDataMap[groupIndex][currentRowIndex] = []\r\n                }\r\n                previousGroupedDataMap[groupIndex][currentRowIndex].push(cell)\r\n            });\r\n            return {\r\n                previousGroupedDataMap: previousGroupedDataMap,\r\n                previousRowIndex: currentRowIndex,\r\n                previousGroupIndex: currentGroupIndex\r\n            }\r\n        }, {\r\n            previousGroupedDataMap: [],\r\n            previousRowIndex: -1,\r\n            previousGroupIndex: -1\r\n        });\r\n        var allDayPanelGroupedMap = [];\r\n        null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(cell => {\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = cell.cellData;\r\n            if (!allDayPanelGroupedMap[groupIndex]) {\r\n                allDayPanelGroupedMap[groupIndex] = []\r\n            }\r\n            allDayPanelGroupedMap[groupIndex].push(cell)\r\n        });\r\n        return {\r\n            allDayPanelGroupedMap: allDayPanelGroupedMap,\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        }\r\n    }\r\n    _isFirstGroupCell(rowIndex, columnIndex, options) {\r\n        var {\r\n            groupOrientation: groupOrientation,\r\n            rowCountInGroup: rowCountInGroup,\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            groupCount: groupCount\r\n        } = options;\r\n        if (this.workspace.isGroupedByDate()) {\r\n            return columnIndex % groupCount === 0\r\n        }\r\n        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\r\n            return columnIndex % cellCountInGroupRow === 0\r\n        }\r\n        return rowIndex % rowCountInGroup === 0\r\n    }\r\n    _isLastGroupCell(rowIndex, columnIndex, options) {\r\n        var {\r\n            groupOrientation: groupOrientation,\r\n            rowCountInGroup: rowCountInGroup,\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            groupCount: groupCount\r\n        } = options;\r\n        if (this.workspace.isGroupedByDate()) {\r\n            return (columnIndex + 1) % groupCount === 0\r\n        }\r\n        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\r\n            return (columnIndex + 1) % cellCountInGroupRow === 0\r\n        }\r\n        return (rowIndex + 1) % rowCountInGroup === 0\r\n    }\r\n}\r\nclass GroupedDataMapProvider {\r\n    constructor(viewDataGenerator, viewDataMap, completeViewDataMap, workspace) {\r\n        this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);\r\n        this.completeViewDataMap = completeViewDataMap;\r\n        this._workspace = workspace\r\n    }\r\n    get isVerticalGroupedWorkspace() {\r\n        return this._workspace._isVerticalGroupedWorkSpace()\r\n    }\r\n    getGroupStartDate(groupIndex) {\r\n        var firstRow = this.getFirstGroupRow(groupIndex);\r\n        if (firstRow) {\r\n            var {\r\n                startDate: startDate\r\n            } = firstRow[0].cellData;\r\n            return startDate\r\n        }\r\n    }\r\n    getGroupEndDate(groupIndex) {\r\n        var lastRow = this.getLastGroupRow(groupIndex);\r\n        if (lastRow) {\r\n            var lastCellIndex = lastRow.length - 1;\r\n            var {\r\n                cellData: cellData\r\n            } = lastRow[lastCellIndex];\r\n            var {\r\n                endDate: endDate\r\n            } = cellData;\r\n            return endDate\r\n        }\r\n    }\r\n    findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay) {\r\n        if (isAllDay) {\r\n            return this.findAllDayGroupCellStartDate(groupIndex, startDate)\r\n        }\r\n        var groupData = this.getGroupFromDateTableGroupMap(groupIndex);\r\n        var checkCellStartDate = (rowIndex, cellIndex) => {\r\n            var {\r\n                cellData: cellData\r\n            } = groupData[rowIndex][cellIndex];\r\n            var {\r\n                startDate: secondMin,\r\n                endDate: secondMax\r\n            } = cellData;\r\n            if (dateUtils.intervalsOverlap({\r\n                    firstMin: startDate,\r\n                    firstMax: endDate,\r\n                    secondMin: secondMin,\r\n                    secondMax: secondMax\r\n                })) {\r\n                return secondMin\r\n            }\r\n        };\r\n        var startDateVerticalSearch = (() => {\r\n            var cellCount = groupData[0].length;\r\n            for (var cellIndex = 0; cellIndex < cellCount; ++cellIndex) {\r\n                for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\r\n                    var result = checkCellStartDate(rowIndex, cellIndex);\r\n                    if (result) {\r\n                        return result\r\n                    }\r\n                }\r\n            }\r\n        })();\r\n        var startDateHorizontalSearch = (() => {\r\n            for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\r\n                var row = groupData[rowIndex];\r\n                for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {\r\n                    var result = checkCellStartDate(rowIndex, cellIndex);\r\n                    if (result) {\r\n                        return result\r\n                    }\r\n                }\r\n            }\r\n        })();\r\n        return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch\r\n    }\r\n    findAllDayGroupCellStartDate(groupIndex, startDate) {\r\n        var groupStartDate = this.getGroupStartDate(groupIndex);\r\n        return groupStartDate > startDate ? groupStartDate : startDate\r\n    }\r\n    findCellPositionInMap(cellInfo) {\r\n        var {\r\n            groupIndex: groupIndex,\r\n            startDate: startDate,\r\n            isAllDay: isAllDay,\r\n            index: index\r\n        } = cellInfo;\r\n        var startTime = isAllDay ? dateUtils.trimTime(startDate).getTime() : startDate.getTime();\r\n        var isStartDateInCell = cellData => {\r\n            if (!this._workspace.isDateAndTimeView) {\r\n                return dateUtils.sameDate(startDate, cellData.startDate)\r\n            }\r\n            var cellStartTime = cellData.startDate.getTime();\r\n            var cellEndTime = cellData.endDate.getTime();\r\n            return isAllDay ? cellData.allDay && startTime >= cellStartTime && startTime <= cellEndTime : startTime >= cellStartTime && startTime < cellEndTime\r\n        };\r\n        var {\r\n            allDayPanelGroupedMap: allDayPanelGroupedMap,\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var rows = isAllDay && !this._workspace._isVerticalGroupedWorkSpace() ? [allDayPanelGroupedMap[groupIndex]] || [] : dateTableGroupedMap[groupIndex] || [];\r\n        for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\r\n            var row = rows[rowIndex];\r\n            for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {\r\n                var cell = row[cellIndex];\r\n                var {\r\n                    cellData: cellData\r\n                } = cell;\r\n                if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {\r\n                    if (isStartDateInCell(cellData)) {\r\n                        return cell.position\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return\r\n    }\r\n    _isSameGroupIndexAndIndex(cellData, groupIndex, index) {\r\n        return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index)\r\n    }\r\n    getCellsGroup(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var groupData = dateTableGroupedMap[groupIndex];\r\n        if (groupData) {\r\n            var {\r\n                cellData: cellData\r\n            } = groupData[0][0];\r\n            return cellData.groups\r\n        }\r\n    }\r\n    getCompletedGroupsInfo() {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        return dateTableGroupedMap.map(groupData => {\r\n            var firstCell = groupData[0][0];\r\n            var {\r\n                allDay: allDay,\r\n                groupIndex: groupIndex\r\n            } = firstCell.cellData;\r\n            return {\r\n                allDay: allDay,\r\n                groupIndex: groupIndex,\r\n                startDate: this.getGroupStartDate(groupIndex),\r\n                endDate: this.getGroupEndDate(groupIndex)\r\n            }\r\n        }).filter(_ref7 => {\r\n            var {\r\n                startDate: startDate\r\n            } = _ref7;\r\n            return !!startDate\r\n        })\r\n    }\r\n    getGroupIndices() {\r\n        return this.getCompletedGroupsInfo().map(_ref8 => {\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = _ref8;\r\n            return groupIndex\r\n        })\r\n    }\r\n    getGroupFromDateTableGroupMap(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        return dateTableGroupedMap[groupIndex]\r\n    }\r\n    getFirstGroupRow(groupIndex) {\r\n        var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);\r\n        if (groupedData) {\r\n            var {\r\n                cellData: cellData\r\n            } = groupedData[0][0];\r\n            return !cellData.allDay ? groupedData[0] : groupedData[1]\r\n        }\r\n    }\r\n    getLastGroupRow(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var groupedData = dateTableGroupedMap[groupIndex];\r\n        if (groupedData) {\r\n            var lastRowIndex = groupedData.length - 1;\r\n            return groupedData[lastRowIndex]\r\n        }\r\n    }\r\n    getLastGroupCell(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var groupedRows = dateTableGroupedMap[groupIndex];\r\n        var lastRow = groupedRows[groupedRows.length - 1];\r\n        var result;\r\n        if (lastRow) {\r\n            var cellCount = lastRow.length;\r\n            result = lastRow[cellCount - 1]\r\n        }\r\n        return result\r\n    }\r\n    getLastGroupCellPosition(groupIndex) {\r\n        var _groupCell;\r\n        var groupCell;\r\n        if (this.isVerticalGroupedWorkspace) {\r\n            var groupRow = this.getLastGroupRow(groupIndex);\r\n            groupCell = groupRow[groupRow.length - 1]\r\n        } else {\r\n            groupCell = this.getLastGroupCell(groupIndex)\r\n        }\r\n        return null === (_groupCell = groupCell) || void 0 === _groupCell ? void 0 : _groupCell.position\r\n    }\r\n    getRowCountInGroup(groupIndex) {\r\n        var groupRow = this.getLastGroupRow(groupIndex);\r\n        var cellAmount = groupRow.length;\r\n        var lastCellData = groupRow[cellAmount - 1].cellData;\r\n        var lastCellIndex = lastCellData.index;\r\n        return (lastCellIndex + 1) / groupRow.length\r\n    }\r\n}\r\nexport default class ViewDataProvider {\r\n    constructor(workspace) {\r\n        this._viewDataGenerator = null;\r\n        this._viewData = [];\r\n        this._completeViewDataMap = [];\r\n        this._completeDateHeaderMap = [];\r\n        this._viewDataMap = [];\r\n        this._groupedDataMapProvider = null;\r\n        this._workspace = workspace\r\n    }\r\n    get viewDataGenerator() {\r\n        if (!this._viewDataGenerator) {\r\n            this._viewDataGenerator = new ViewDataGenerator(this._workspace)\r\n        }\r\n        return this._viewDataGenerator\r\n    }\r\n    get completeViewDataMap() {\r\n        return this._completeViewDataMap\r\n    }\r\n    set completeViewDataMap(value) {\r\n        this._completeViewDataMap = value\r\n    }\r\n    get completeDateHeaderMap() {\r\n        return this._completeDateHeaderMap\r\n    }\r\n    set completeDateHeaderMap(value) {\r\n        this._completeDateHeaderMap = value\r\n    }\r\n    get completeTimePanelMap() {\r\n        return this._completeTimePanelMap\r\n    }\r\n    set completeTimePanelMap(value) {\r\n        this._completeTimePanelMap = value\r\n    }\r\n    get viewData() {\r\n        return this._viewData\r\n    }\r\n    set viewData(value) {\r\n        this._viewData = value\r\n    }\r\n    get viewDataMap() {\r\n        return this._viewDataMap\r\n    }\r\n    set viewDataMap(value) {\r\n        this._viewDataMap = value\r\n    }\r\n    get dateHeaderData() {\r\n        return this._dateHeaderData\r\n    }\r\n    set dateHeaderData(value) {\r\n        this._dateHeaderData = value\r\n    }\r\n    get timePanelData() {\r\n        return this._timePanelData\r\n    }\r\n    set timePanelData(value) {\r\n        this._timePanelData = value\r\n    }\r\n    get groupedDataMap() {\r\n        return this._groupedDataMapProvider.groupedDataMap\r\n    }\r\n    get isVerticalGroupedWorkspace() {\r\n        return this._workspace._isVerticalGroupedWorkSpace()\r\n    }\r\n    update(isGenerateNewViewData) {\r\n        var {\r\n            viewDataGenerator: viewDataGenerator,\r\n            _workspace: _workspace\r\n        } = this;\r\n        var renderOptions = _workspace.generateRenderOptions();\r\n        if (isGenerateNewViewData) {\r\n            this.completeViewDataMap = viewDataGenerator._getCompleteViewDataMap(renderOptions);\r\n            this.completeDateHeaderMap = viewDataGenerator._getCompleteDateHeaderMap(renderOptions, this.completeViewDataMap);\r\n            this.completeTimePanelMap = viewDataGenerator._getCompleteTimePanelMap(renderOptions, this.completeViewDataMap)\r\n        }\r\n        this.viewDataMap = viewDataGenerator._generateViewDataMap(this.completeViewDataMap, renderOptions);\r\n        this.viewData = viewDataGenerator._getViewDataFromMap(this.viewDataMap, renderOptions);\r\n        this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, this._workspace);\r\n        this.dateHeaderData = viewDataGenerator._generateDateHeaderData(this.completeDateHeaderMap, renderOptions);\r\n        this.timePanelData = viewDataGenerator._generateTimePanelData(this.completeTimePanelMap, renderOptions)\r\n    }\r\n    getStartDate() {\r\n        var {\r\n            groupedData: groupedData\r\n        } = this.viewData;\r\n        var {\r\n            dateTable: dateTable\r\n        } = groupedData[0];\r\n        return dateTable[0][0].startDate\r\n    }\r\n    getGroupStartDate(groupIndex) {\r\n        return this._groupedDataMapProvider.getGroupStartDate(groupIndex)\r\n    }\r\n    getGroupEndDate(groupIndex) {\r\n        return this._groupedDataMapProvider.getGroupEndDate(groupIndex)\r\n    }\r\n    findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay) {\r\n        return this._groupedDataMapProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay)\r\n    }\r\n    findAllDayGroupCellStartDate(groupIndex, startDate) {\r\n        return this._groupedDataMapProvider.findAllDayGroupCellStartDate(groupIndex, startDate)\r\n    }\r\n    findCellPositionInMap(cellInfo) {\r\n        return this._groupedDataMapProvider.findCellPositionInMap(cellInfo)\r\n    }\r\n    getCellsGroup(groupIndex) {\r\n        return this._groupedDataMapProvider.getCellsGroup(groupIndex)\r\n    }\r\n    getCompletedGroupsInfo() {\r\n        return this._groupedDataMapProvider.getCompletedGroupsInfo()\r\n    }\r\n    getGroupIndices() {\r\n        return this._groupedDataMapProvider.getGroupIndices()\r\n    }\r\n    getLastGroupCellPosition(groupIndex) {\r\n        return this._groupedDataMapProvider.getLastGroupCellPosition(groupIndex)\r\n    }\r\n    getRowCountInGroup(groupIndex) {\r\n        return this._groupedDataMapProvider.getRowCountInGroup(groupIndex)\r\n    }\r\n    getCellData(rowIndex, cellIndex, isAllDay) {\r\n        if (isAllDay && !this.isVerticalGroupedWorkspace) {\r\n            return this._viewData.groupedData[0].allDayPanel[cellIndex]\r\n        }\r\n        var {\r\n            dateTableMap: dateTableMap\r\n        } = this.viewDataMap;\r\n        var {\r\n            cellData: cellData\r\n        } = dateTableMap[rowIndex][cellIndex];\r\n        return cellData\r\n    }\r\n    getCellsByGroupIndexAndAllDay(groupIndex, allDay) {\r\n        var workspace = this._workspace;\r\n        var rowsPerGroup = workspace._getRowCountWithAllDayRows();\r\n        var isShowAllDayPanel = workspace.isAllDayPanelVisible;\r\n        var firstRowInGroup = this.isVerticalGroupedWorkspace ? groupIndex * rowsPerGroup : 0;\r\n        var lastRowInGroup = this.isVerticalGroupedWorkspace ? (groupIndex + 1) * rowsPerGroup - 1 : rowsPerGroup;\r\n        var correctedFirstRow = isShowAllDayPanel && !allDay ? firstRowInGroup + 1 : firstRowInGroup;\r\n        var correctedLastRow = allDay ? correctedFirstRow : lastRowInGroup;\r\n        return this.completeViewDataMap.slice(correctedFirstRow, correctedLastRow + 1).map(row => row.filter(_ref9 => {\r\n            var {\r\n                groupIndex: currentGroupIndex\r\n            } = _ref9;\r\n            return groupIndex === currentGroupIndex\r\n        }))\r\n    }\r\n    getGroupData(groupIndex) {\r\n        var {\r\n            groupedData: groupedData\r\n        } = this.viewData;\r\n        if (this.isVerticalGroupedWorkspace) {\r\n            return groupedData.filter(item => item.groupIndex === groupIndex)[0]\r\n        }\r\n        var filterCells = row => null === row || void 0 === row ? void 0 : row.filter(cell => cell.groupIndex === groupIndex);\r\n        var {\r\n            allDayPanel: allDayPanel,\r\n            dateTable: dateTable\r\n        } = groupedData[0];\r\n        var filteredDateTable = [];\r\n        dateTable.forEach(row => {\r\n            filteredDateTable.push(filterCells(row))\r\n        });\r\n        return {\r\n            allDayPanel: filterCells(allDayPanel),\r\n            dateTable: filteredDateTable\r\n        }\r\n    }\r\n    getCellCountWithGroup(groupIndex) {\r\n        var rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        return dateTableGroupedMap.filter((_, index) => index <= groupIndex).reduce((previous, row) => previous + row[rowIndex].length, 0)\r\n    }\r\n    getAllDayPanel(groupIndex) {\r\n        var groupData = this.getGroupData(groupIndex);\r\n        return null === groupData || void 0 === groupData ? void 0 : groupData.allDayPanel\r\n    }\r\n    isGroupIntersectDateInterval(groupIndex, startDate, endDate) {\r\n        var groupStartDate = this.getGroupStartDate(groupIndex);\r\n        var groupEndDate = this.getGroupEndDate(groupIndex);\r\n        return startDate < groupEndDate && endDate > groupStartDate\r\n    }\r\n    findGlobalCellPosition(date) {\r\n        var groupIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\r\n        var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\r\n        var {\r\n            completeViewDataMap: completeViewDataMap,\r\n            _workspace: workspace\r\n        } = this;\r\n        var showAllDayPanel = workspace.isAllDayPanelVisible;\r\n        for (var rowIndex = 0; rowIndex < completeViewDataMap.length; rowIndex += 1) {\r\n            var currentRow = completeViewDataMap[rowIndex];\r\n            for (var columnIndex = 0; columnIndex < currentRow.length; columnIndex += 1) {\r\n                var cellData = currentRow[columnIndex];\r\n                var {\r\n                    startDate: currentStartDate,\r\n                    endDate: currentEndDate,\r\n                    groupIndex: currentGroupIndex,\r\n                    allDay: currentAllDay\r\n                } = cellData;\r\n                if (groupIndex === currentGroupIndex && allDay === !!currentAllDay && this._compareDatesAndAllDay(date, currentStartDate, currentEndDate, allDay)) {\r\n                    return {\r\n                        position: {\r\n                            columnIndex: columnIndex,\r\n                            rowIndex: showAllDayPanel && !this.isVerticalGroupedWorkspace ? rowIndex - 1 : rowIndex\r\n                        },\r\n                        cellData: cellData\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _compareDatesAndAllDay(date, cellStartDate, cellEndDate, allDay) {\r\n        var time = date.getTime();\r\n        var trimmedTime = dateUtils.trimTime(date).getTime();\r\n        var cellStartTime = cellStartDate.getTime();\r\n        var cellEndTime = cellEndDate.getTime();\r\n        return !allDay && time >= cellStartTime && time < cellEndTime || allDay && trimmedTime === cellStartTime\r\n    }\r\n    getSkippedDaysCount(groupIndex, startDate, endDate, daysCount) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this._groupedDataMapProvider.groupedDataMap;\r\n        var groupedData = dateTableGroupedMap[groupIndex];\r\n        var includedDays = 0;\r\n        for (var rowIndex = 0; rowIndex < groupedData.length; rowIndex += 1) {\r\n            for (var columnIndex = 0; columnIndex < groupedData[rowIndex].length; columnIndex += 1) {\r\n                var cell = groupedData[rowIndex][columnIndex].cellData;\r\n                if (startDate.getTime() < cell.endDate.getTime() && endDate.getTime() > cell.startDate.getTime()) {\r\n                    includedDays += 1\r\n                }\r\n            }\r\n        }\r\n        var lastCell = groupedData[groupedData.length - 1][groupedData[0].length - 1].cellData;\r\n        var lastCellStart = dateUtils.trimTime(lastCell.startDate);\r\n        var daysAfterView = Math.floor((endDate.getTime() - lastCellStart.getTime()) / dateUtils.dateToMilliseconds(\"day\"));\r\n        var deltaDays = daysAfterView > 0 ? daysAfterView : 0;\r\n        return daysCount - includedDays - deltaDays\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}