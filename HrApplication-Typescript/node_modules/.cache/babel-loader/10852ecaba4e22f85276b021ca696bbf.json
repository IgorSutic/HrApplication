{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/appointmentSettingsGenerator.js)\r\n * Version: 21.1.6\r\n * Build date: Mon Sep 27 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../core/utils/date\";\nimport { isEmptyObject } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { getRecurrenceProcessor } from \"./recurrence\";\nimport timeZoneUtils from \"./utils.timeZone.js\";\nvar toMs = dateUtils.dateToMilliseconds;\nexport class AppointmentSettingsGenerator {\n  constructor(scheduler) {\n    this.scheduler = scheduler;\n    this.settingsStrategy = this.scheduler.isVirtualScrolling() ? new AppointmentSettingsGeneratorVirtualStrategy(this.scheduler) : new AppointmentSettingsGeneratorBaseStrategy(this.scheduler);\n  }\n\n  create(rawAppointment) {\n    return this.settingsStrategy.create(rawAppointment);\n  }\n\n}\nexport class AppointmentSettingsGeneratorBaseStrategy {\n  constructor(scheduler) {\n    this.scheduler = scheduler;\n  }\n\n  get timeZoneCalculator() {\n    return this.scheduler.timeZoneCalculator;\n  }\n\n  get workspace() {\n    return this.scheduler.getWorkSpace();\n  }\n\n  get viewDataProvider() {\n    return this.workspace.viewDataProvider;\n  }\n\n  create(rawAppointment) {\n    var {\n      scheduler: scheduler\n    } = this;\n    var appointment = scheduler.createAppointmentAdapter(rawAppointment);\n\n    var itemResources = scheduler._resourcesManager.getResourcesFromItem(rawAppointment);\n\n    var isAllDay = this._isAllDayAppointment(rawAppointment);\n\n    var appointmentList = this._createAppointments(appointment, itemResources);\n\n    appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointment);\n\n    if (this._canProcessNotNativeTimezoneDates(appointment)) {\n      appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointment);\n    }\n\n    var gridAppointmentList = this._createGridAppointmentList(appointmentList, appointment);\n\n    gridAppointmentList = this._cropAppointmentsByStartDayHour(gridAppointmentList, rawAppointment, isAllDay);\n    gridAppointmentList = this._getProcessedLongAppointmentsIfRequired(gridAppointmentList, appointment);\n    var appointmentInfos = this.createAppointmentInfos(gridAppointmentList, itemResources, isAllDay, appointment.isRecurrent);\n    return appointmentInfos;\n  }\n\n  _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\n    var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\n\n    if (appointmentList.length > 1 && hasAppointmentTimeZone) {\n      var appointmentOffsets = {\n        startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\n        endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\n      };\n      appointmentList.forEach(a => {\n        var sourceOffsets_startDate = this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\n            sourceOffsets_endDate = this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\n        var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\n        var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\n\n        if (sourceOffsets_startDate.appointment !== sourceOffsets_startDate.common) {\n          a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"));\n        }\n\n        if (sourceOffsets_endDate.appointment !== sourceOffsets_endDate.common) {\n          a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"));\n        }\n      });\n    }\n\n    return appointmentList;\n  }\n\n  _isAllDayAppointment(rawAppointment) {\n    return this.scheduler.appointmentTakesAllDay(rawAppointment) && this.workspace.supportAllDayRow();\n  }\n\n  _createAppointments(appointment, resources) {\n    var appointments = this._createRecurrenceAppointments(appointment, resources);\n\n    if (!appointment.isRecurrent && 0 === appointments.length) {\n      appointments.push({\n        startDate: appointment.startDate,\n        endDate: appointment.endDate\n      });\n    }\n\n    appointments = appointments.map(item => {\n      var _item$endDate;\n\n      var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\n\n      if (item.startDate.getTime() === resultEndTime) {\n        item.endDate.setTime(resultEndTime + toMs(\"minute\"));\n      }\n\n      return _extends({}, item, {\n        exceptionDate: new Date(item.startDate)\n      });\n    });\n    return appointments;\n  }\n\n  _canProcessNotNativeTimezoneDates(appointment) {\n    var timeZoneName = this.scheduler.option(\"timeZone\");\n    var isTimeZoneSet = !isEmptyObject(timeZoneName);\n\n    if (!isTimeZoneSet) {\n      return false;\n    }\n\n    if (!appointment.isRecurrent) {\n      return false;\n    }\n\n    return !timeZoneUtils.isEqualLocalTimeZone(timeZoneName, appointment.startDate);\n  }\n\n  _getProcessedNotNativeDateIfCrossDST(date, offset) {\n    if (offset < 0) {\n      var newDate = new Date(date);\n      var newDateMinusOneHour = new Date(newDate);\n      newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\n      var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\n      var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\n\n      if (newDateOffset !== newDateMinusOneHourOffset) {\n        return 0;\n      }\n    }\n\n    return offset;\n  }\n\n  _getCommonOffset(date) {\n    return this.timeZoneCalculator.getOffsets(date).common;\n  }\n\n  _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\n    return appointmentList.map(item => {\n      var diffStartDateOffset = this._getCommonOffset(appointment.startDate) - this._getCommonOffset(item.startDate);\n\n      var diffEndDateOffset = this._getCommonOffset(appointment.endDate) - this._getCommonOffset(item.endDate);\n\n      if (0 === diffStartDateOffset && 0 === diffEndDateOffset) {\n        return item;\n      }\n\n      diffStartDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\n      diffEndDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\n      var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\n      var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\n      var testNewStartDate = this.timeZoneCalculator.createDate(newStartDate, {\n        path: \"toGrid\"\n      });\n      var testNewEndDate = this.timeZoneCalculator.createDate(newEndDate, {\n        path: \"toGrid\"\n      });\n\n      if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\n        newEndDate = new Date(newStartDate.getTime() + appointment.duration);\n      }\n\n      return _extends({}, item, {\n        startDate: newStartDate,\n        endDate: newEndDate,\n        exceptionDate: new Date(newStartDate)\n      });\n    });\n  }\n\n  _getProcessedLongAppointmentsIfRequired(gridAppointmentList, appointment) {\n    var rawAppointment = appointment.source();\n    var allDay = this.scheduler.appointmentTakesAllDay(rawAppointment);\n    var dateRange = this.workspace.getDateRange();\n    var renderingStrategy = this.scheduler.getLayoutManager().getRenderingStrategyInstance();\n\n    if (renderingStrategy.needSeparateAppointment(allDay)) {\n      var longStartDateParts = [];\n      var resultDates = [];\n      gridAppointmentList.forEach(gridAppointment => {\n        var maxDate = new Date(dateRange[1]);\n        var endDateOfPart = renderingStrategy.normalizeEndDateByViewEnd(rawAppointment, gridAppointment.endDate);\n        longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\n          milliseconds: this.scheduler.getWorkSpace().getIntervalDuration(allDay)\n        });\n        var list = longStartDateParts.filter(startDatePart => new Date(startDatePart) < maxDate).map(date => ({\n          startDate: date,\n          endDate: new Date(new Date(date).setMilliseconds(appointment.duration)),\n          source: gridAppointment.source\n        }));\n        resultDates = resultDates.concat(list);\n      });\n      gridAppointmentList = resultDates;\n    }\n\n    return gridAppointmentList;\n  }\n\n  _createGridAppointmentList(appointmentList, appointment) {\n    return appointmentList.map(source => {\n      var offsetDifference = appointment.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\n\n      if (0 !== offsetDifference && this._canProcessNotNativeTimezoneDates(appointment)) {\n        source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\n        source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\n        source.exceptionDate = new Date(source.startDate);\n      }\n\n      var startDate = this.timeZoneCalculator.createDate(source.startDate, {\n        path: \"toGrid\"\n      });\n      var endDate = this.timeZoneCalculator.createDate(source.endDate, {\n        path: \"toGrid\"\n      });\n      return {\n        startDate: startDate,\n        endDate: endDate,\n        source: source\n      };\n    });\n  }\n\n  _createExtremeRecurrenceDates(rawAppointment) {\n    var dateRange = this.scheduler._workSpace.getDateRange();\n\n    var startViewDate = this.scheduler.appointmentTakesAllDay(rawAppointment) ? dateUtils.trimTime(dateRange[0]) : dateRange[0];\n    var endViewDate = dateRange[1];\n    var commonTimeZone = this.scheduler.option(\"timeZone\");\n\n    if (commonTimeZone) {\n      startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\n        path: \"fromGrid\"\n      });\n      endViewDate = this.timeZoneCalculator.createDate(endViewDate, {\n        path: \"fromGrid\"\n      });\n      var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDate);\n\n      if (daylightOffset) {\n        endViewDate = new Date(endViewDate.getTime() + daylightOffset);\n      }\n    }\n\n    return [startViewDate, endViewDate];\n  }\n\n  _createRecurrenceOptions(appointment, groupIndex) {\n    var [minRecurrenceDate, maxRecurrenceDate] = this._createExtremeRecurrenceDates(appointment.source(), groupIndex);\n\n    return {\n      rule: appointment.recurrenceRule,\n      exception: appointment.recurrenceException,\n      min: minRecurrenceDate,\n      max: maxRecurrenceDate,\n      firstDayOfWeek: this.scheduler.getFirstDayOfWeek(),\n      start: appointment.startDate,\n      end: appointment.endDate,\n      getPostProcessedException: date => {\n        var timeZoneName = this.scheduler.option(\"timeZone\");\n\n        if (isEmptyObject(timeZoneName) || timeZoneUtils.isEqualLocalTimeZone(timeZoneName, date)) {\n          return date;\n        }\n\n        var appointmentOffset = this.timeZoneCalculator.getOffsets(appointment.startDate).common;\n        var exceptionAppointmentOffset = this.timeZoneCalculator.getOffsets(date).common;\n        var diff = appointmentOffset - exceptionAppointmentOffset;\n        diff = this._getProcessedNotNativeDateIfCrossDST(date, diff);\n        return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"));\n      }\n    };\n  }\n\n  _createRecurrenceAppointments(appointment, resources) {\n    var {\n      duration: duration\n    } = appointment;\n\n    var option = this._createRecurrenceOptions(appointment);\n\n    var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n    return generatedStartDates.map(date => {\n      var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n      utcDate.setTime(utcDate.getTime() + duration);\n      var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n      return {\n        startDate: new Date(date),\n        endDate: endDate\n      };\n    });\n  }\n\n  _cropAppointmentsByStartDayHour(appointments, rawAppointment, isAllDay) {\n    return appointments.map(appointment => {\n      var startDate = new Date(appointment.startDate);\n\n      var firstViewDate = this._getAppointmentFirstViewDate(appointment, rawAppointment);\n\n      var startDayHour = this._getViewStartDayHour(firstViewDate);\n\n      appointment.startDate = this._getAppointmentResultDate({\n        appointment: appointment,\n        rawAppointment: rawAppointment,\n        startDate: startDate,\n        startDayHour: startDayHour,\n        firstViewDate: firstViewDate\n      });\n      return appointment;\n    });\n  }\n\n  _getAppointmentFirstViewDate() {\n    return this.scheduler.getStartViewDate();\n  }\n\n  _getViewStartDayHour() {\n    return this.scheduler._getCurrentViewOption(\"startDayHour\");\n  }\n\n  _getAppointmentResultDate(options) {\n    var {\n      appointment: appointment,\n      rawAppointment: rawAppointment,\n      startDayHour: startDayHour,\n      firstViewDate: firstViewDate\n    } = options;\n    var {\n      startDate: startDate\n    } = options;\n    var resultDate = new Date(appointment.startDate);\n\n    if (this.scheduler.appointmentTakesAllDay(rawAppointment)) {\n      resultDate = dateUtils.normalizeDate(startDate, firstViewDate);\n    } else {\n      if (startDate < firstViewDate) {\n        startDate = firstViewDate;\n      }\n\n      resultDate = dateUtils.normalizeDate(appointment.startDate, startDate);\n    }\n\n    return dateUtils.roundDateByStartDayHour(resultDate, startDayHour);\n  }\n\n  createAppointmentInfos(gridAppointments, resources, isAllDay, recurrent) {\n    var _this = this;\n\n    var result = [];\n\n    var _loop = function (i) {\n      var appointment = gridAppointments[i];\n\n      var coordinates = _this.getCoordinates({\n        appointment: appointment,\n        resources: resources,\n        isAllDay: isAllDay,\n        recurrent: recurrent\n      });\n\n      coordinates.forEach(coordinate => {\n        extend(coordinate, {\n          info: {\n            appointment: gridAppointments[i],\n            sourceAppointment: gridAppointments[i].source\n          }\n        });\n      });\n      result = result.concat(coordinates);\n    };\n\n    for (var i = 0; i < gridAppointments.length; i++) {\n      _loop(i);\n    }\n\n    return result;\n  }\n\n  getCoordinates(options) {\n    var {\n      appointment: appointment,\n      resources: resources,\n      isAllDay: isAllDay\n    } = options;\n    return this.workspace.getCoordinatesByDateInGroup(appointment.startDate, resources, isAllDay);\n  }\n\n}\nexport class AppointmentSettingsGeneratorVirtualStrategy extends AppointmentSettingsGeneratorBaseStrategy {\n  get viewDataProvider() {\n    return this.workspace.viewDataProvider;\n  }\n\n  get isVerticalGrouping() {\n    return this.workspace._isVerticalGroupedWorkSpace();\n  }\n\n  createAppointmentInfos(gridAppointments, resources, allDay, recurrent) {\n    var appointments = allDay ? gridAppointments : gridAppointments.filter(_ref => {\n      var {\n        source: source,\n        startDate: startDate,\n        endDate: endDate\n      } = _ref;\n      var {\n        groupIndex: groupIndex\n      } = source;\n      return this.viewDataProvider.isGroupIntersectDateInterval(groupIndex, startDate, endDate);\n    });\n\n    if (recurrent) {\n      return this._createRecurrentAppointmentInfos(appointments, resources, allDay);\n    }\n\n    return super.createAppointmentInfos(appointments, resources, allDay, recurrent);\n  }\n\n  getCoordinates(options) {\n    var {\n      appointment: appointment,\n      isAllDay: isAllDay,\n      resources: resources,\n      recurrent: recurrent\n    } = options;\n    var {\n      startDate: startDate\n    } = appointment;\n    var {\n      workspace: workspace\n    } = this;\n    var groupIndex = !recurrent ? appointment.source.groupIndex : void 0;\n    return workspace.getCoordinatesByDateInGroup(startDate, resources, isAllDay, groupIndex);\n  }\n\n  _createRecurrentAppointmentInfos(gridAppointments, resources, allDay) {\n    var result = [];\n    gridAppointments.forEach(appointment => {\n      var {\n        source: source\n      } = appointment;\n      var {\n        groupIndex: groupIndex\n      } = source;\n      var coordinate = this.workspace.getCoordinatesByDate(appointment.startDate, groupIndex, allDay);\n\n      if (coordinate) {\n        extend(coordinate, {\n          info: {\n            appointment: appointment,\n            sourceAppointment: source\n          }\n        });\n        result.push(coordinate);\n      }\n    });\n    return result;\n  }\n\n  _cropAppointmentsByStartDayHour(appointments, rawAppointment, isAllDay) {\n    return appointments.filter(appointment => {\n      var firstViewDate = this._getAppointmentFirstViewDate(appointment, rawAppointment);\n\n      if (!firstViewDate) {\n        return false;\n      }\n\n      var startDayHour = this._getViewStartDayHour(firstViewDate);\n\n      var startDate = new Date(appointment.startDate);\n      appointment.startDate = this._getAppointmentResultDate({\n        appointment: appointment,\n        rawAppointment: rawAppointment,\n        startDate: startDate,\n        startDayHour: startDayHour,\n        firstViewDate: firstViewDate\n      });\n      return !isAllDay ? appointment.endDate > appointment.startDate : true;\n    });\n  }\n\n  _createRecurrenceAppointments(appointment, resources) {\n    var {\n      duration: duration\n    } = appointment;\n    var result = [];\n    var groupIndices = this.workspace._getGroupCount() ? this._getGroupIndices(resources) : [0];\n    groupIndices.forEach(groupIndex => {\n      var option = this._createRecurrenceOptions(appointment, groupIndex);\n\n      var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n      var recurrentInfo = generatedStartDates.map(date => {\n        var startDate = new Date(date);\n        var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n        utcDate.setTime(utcDate.getTime() + duration);\n        var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n        return {\n          startDate: startDate,\n          endDate: endDate,\n          groupIndex: groupIndex\n        };\n      });\n      result.push(...recurrentInfo);\n    });\n    return result;\n  }\n\n  _getViewStartDayHour(firstViewDate) {\n    return firstViewDate.getHours();\n  }\n\n  _getAppointmentFirstViewDate(appointment, rawAppointment) {\n    var {\n      viewDataProvider: viewDataProvider\n    } = this.scheduler.getWorkSpace();\n    var {\n      groupIndex: groupIndex\n    } = appointment.source;\n    var {\n      startDate: startDate,\n      endDate: endDate\n    } = appointment;\n\n    var isAllDay = this._isAllDayAppointment(rawAppointment);\n\n    return viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay);\n  }\n\n  _updateGroupIndices(appointments, itemResources) {\n    var groupIndices = this._getGroupIndices(itemResources);\n\n    var result = [];\n    groupIndices.forEach(groupIndex => {\n      var groupStartDate = this.viewDataProvider.getGroupStartDate(groupIndex);\n\n      if (groupStartDate) {\n        appointments.forEach(appointment => {\n          var appointmentCopy = extend({}, appointment);\n          appointmentCopy.groupIndex = groupIndex;\n          result.push(appointmentCopy);\n        });\n      }\n    });\n    return result;\n  }\n\n  _getGroupIndices(resources) {\n    var _groupIndices;\n\n    var groupIndices = this.workspace._getGroupIndexes(resources);\n\n    var {\n      viewDataProvider: viewDataProvider\n    } = this.workspace;\n    var viewDataGroupIndices = viewDataProvider.getGroupIndices();\n\n    if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {\n      groupIndices = [0];\n    }\n\n    return groupIndices.filter(groupIndex => -1 !== viewDataGroupIndices.indexOf(groupIndex));\n  }\n\n  _createAppointments(appointment, resources) {\n    var appointments = super._createAppointments(appointment, resources);\n\n    return !appointment.isRecurrent ? this._updateGroupIndices(appointments, resources) : appointments;\n  }\n\n}","map":{"version":3,"sources":["/home/igor/node_modules/devextreme/esm/ui/scheduler/appointmentSettingsGenerator.js"],"names":["_extends","dateUtils","isEmptyObject","extend","getRecurrenceProcessor","timeZoneUtils","toMs","dateToMilliseconds","AppointmentSettingsGenerator","constructor","scheduler","settingsStrategy","isVirtualScrolling","AppointmentSettingsGeneratorVirtualStrategy","AppointmentSettingsGeneratorBaseStrategy","create","rawAppointment","timeZoneCalculator","workspace","getWorkSpace","viewDataProvider","appointment","createAppointmentAdapter","itemResources","_resourcesManager","getResourcesFromItem","isAllDay","_isAllDayAppointment","appointmentList","_createAppointments","_getProcessedByAppointmentTimeZone","_canProcessNotNativeTimezoneDates","_getProcessedNotNativeTimezoneDates","gridAppointmentList","_createGridAppointmentList","_cropAppointmentsByStartDayHour","_getProcessedLongAppointmentsIfRequired","appointmentInfos","createAppointmentInfos","isRecurrent","hasAppointmentTimeZone","startDateTimeZone","endDateTimeZone","length","appointmentOffsets","startDate","getOffsets","endDate","forEach","a","sourceOffsets_startDate","sourceOffsets_endDate","startDateOffsetDiff","endDateOffsetDiff","common","Date","getTime","appointmentTakesAllDay","supportAllDayRow","resources","appointments","_createRecurrenceAppointments","push","map","item","_item$endDate","resultEndTime","setTime","exceptionDate","timeZoneName","option","isTimeZoneSet","isEqualLocalTimeZone","_getProcessedNotNativeDateIfCrossDST","date","offset","newDate","newDateMinusOneHour","setHours","getHours","newDateOffset","newDateMinusOneHourOffset","_getCommonOffset","diffStartDateOffset","diffEndDateOffset","newStartDate","newEndDate","testNewStartDate","createDate","path","testNewEndDate","duration","source","allDay","dateRange","getDateRange","renderingStrategy","getLayoutManager","getRenderingStrategyInstance","needSeparateAppointment","longStartDateParts","resultDates","gridAppointment","maxDate","endDateOfPart","normalizeEndDateByViewEnd","getDatesOfInterval","milliseconds","getIntervalDuration","list","filter","startDatePart","setMilliseconds","concat","offsetDifference","getTimezoneOffset","_createExtremeRecurrenceDates","_workSpace","startViewDate","trimTime","endViewDate","commonTimeZone","daylightOffset","getDaylightOffsetInMs","_createRecurrenceOptions","groupIndex","minRecurrenceDate","maxRecurrenceDate","rule","recurrenceRule","exception","recurrenceException","min","max","firstDayOfWeek","getFirstDayOfWeek","start","end","getPostProcessedException","appointmentOffset","exceptionAppointmentOffset","diff","generatedStartDates","generateDates","utcDate","createUTCDateWithLocalOffset","createDateFromUTCWithLocalOffset","firstViewDate","_getAppointmentFirstViewDate","startDayHour","_getViewStartDayHour","_getAppointmentResultDate","getStartViewDate","_getCurrentViewOption","options","resultDate","normalizeDate","roundDateByStartDayHour","gridAppointments","recurrent","_this","result","_loop","i","coordinates","getCoordinates","coordinate","info","sourceAppointment","getCoordinatesByDateInGroup","isVerticalGrouping","_isVerticalGroupedWorkSpace","_ref","isGroupIntersectDateInterval","_createRecurrentAppointmentInfos","getCoordinatesByDate","groupIndices","_getGroupCount","_getGroupIndices","recurrentInfo","findGroupCellStartDate","_updateGroupIndices","groupStartDate","getGroupStartDate","appointmentCopy","_groupIndices","_getGroupIndexes","viewDataGroupIndices","getGroupIndices","indexOf"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/appointmentSettingsGenerator.js)\r\n * Version: 21.1.6\r\n * Build date: Mon Sep 27 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport dateUtils from \"../../core/utils/date\";\r\nimport {\r\n    isEmptyObject\r\n} from \"../../core/utils/type\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    getRecurrenceProcessor\r\n} from \"./recurrence\";\r\nimport timeZoneUtils from \"./utils.timeZone.js\";\r\nvar toMs = dateUtils.dateToMilliseconds;\r\nexport class AppointmentSettingsGenerator {\r\n    constructor(scheduler) {\r\n        this.scheduler = scheduler;\r\n        this.settingsStrategy = this.scheduler.isVirtualScrolling() ? new AppointmentSettingsGeneratorVirtualStrategy(this.scheduler) : new AppointmentSettingsGeneratorBaseStrategy(this.scheduler)\r\n    }\r\n    create(rawAppointment) {\r\n        return this.settingsStrategy.create(rawAppointment)\r\n    }\r\n}\r\nexport class AppointmentSettingsGeneratorBaseStrategy {\r\n    constructor(scheduler) {\r\n        this.scheduler = scheduler\r\n    }\r\n    get timeZoneCalculator() {\r\n        return this.scheduler.timeZoneCalculator\r\n    }\r\n    get workspace() {\r\n        return this.scheduler.getWorkSpace()\r\n    }\r\n    get viewDataProvider() {\r\n        return this.workspace.viewDataProvider\r\n    }\r\n    create(rawAppointment) {\r\n        var {\r\n            scheduler: scheduler\r\n        } = this;\r\n        var appointment = scheduler.createAppointmentAdapter(rawAppointment);\r\n        var itemResources = scheduler._resourcesManager.getResourcesFromItem(rawAppointment);\r\n        var isAllDay = this._isAllDayAppointment(rawAppointment);\r\n        var appointmentList = this._createAppointments(appointment, itemResources);\r\n        appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointment);\r\n        if (this._canProcessNotNativeTimezoneDates(appointment)) {\r\n            appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointment)\r\n        }\r\n        var gridAppointmentList = this._createGridAppointmentList(appointmentList, appointment);\r\n        gridAppointmentList = this._cropAppointmentsByStartDayHour(gridAppointmentList, rawAppointment, isAllDay);\r\n        gridAppointmentList = this._getProcessedLongAppointmentsIfRequired(gridAppointmentList, appointment);\r\n        var appointmentInfos = this.createAppointmentInfos(gridAppointmentList, itemResources, isAllDay, appointment.isRecurrent);\r\n        return appointmentInfos\r\n    }\r\n    _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\r\n        var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\r\n        if (appointmentList.length > 1 && hasAppointmentTimeZone) {\r\n            var appointmentOffsets = {\r\n                startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\r\n                endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\r\n            };\r\n            appointmentList.forEach(a => {\r\n                var sourceOffsets_startDate = this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\r\n                    sourceOffsets_endDate = this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\r\n                var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\r\n                var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\r\n                if (sourceOffsets_startDate.appointment !== sourceOffsets_startDate.common) {\r\n                    a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"))\r\n                }\r\n                if (sourceOffsets_endDate.appointment !== sourceOffsets_endDate.common) {\r\n                    a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"))\r\n                }\r\n            })\r\n        }\r\n        return appointmentList\r\n    }\r\n    _isAllDayAppointment(rawAppointment) {\r\n        return this.scheduler.appointmentTakesAllDay(rawAppointment) && this.workspace.supportAllDayRow()\r\n    }\r\n    _createAppointments(appointment, resources) {\r\n        var appointments = this._createRecurrenceAppointments(appointment, resources);\r\n        if (!appointment.isRecurrent && 0 === appointments.length) {\r\n            appointments.push({\r\n                startDate: appointment.startDate,\r\n                endDate: appointment.endDate\r\n            })\r\n        }\r\n        appointments = appointments.map(item => {\r\n            var _item$endDate;\r\n            var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\r\n            if (item.startDate.getTime() === resultEndTime) {\r\n                item.endDate.setTime(resultEndTime + toMs(\"minute\"))\r\n            }\r\n            return _extends({}, item, {\r\n                exceptionDate: new Date(item.startDate)\r\n            })\r\n        });\r\n        return appointments\r\n    }\r\n    _canProcessNotNativeTimezoneDates(appointment) {\r\n        var timeZoneName = this.scheduler.option(\"timeZone\");\r\n        var isTimeZoneSet = !isEmptyObject(timeZoneName);\r\n        if (!isTimeZoneSet) {\r\n            return false\r\n        }\r\n        if (!appointment.isRecurrent) {\r\n            return false\r\n        }\r\n        return !timeZoneUtils.isEqualLocalTimeZone(timeZoneName, appointment.startDate)\r\n    }\r\n    _getProcessedNotNativeDateIfCrossDST(date, offset) {\r\n        if (offset < 0) {\r\n            var newDate = new Date(date);\r\n            var newDateMinusOneHour = new Date(newDate);\r\n            newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\r\n            var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\r\n            var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\r\n            if (newDateOffset !== newDateMinusOneHourOffset) {\r\n                return 0\r\n            }\r\n        }\r\n        return offset\r\n    }\r\n    _getCommonOffset(date) {\r\n        return this.timeZoneCalculator.getOffsets(date).common\r\n    }\r\n    _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\r\n        return appointmentList.map(item => {\r\n            var diffStartDateOffset = this._getCommonOffset(appointment.startDate) - this._getCommonOffset(item.startDate);\r\n            var diffEndDateOffset = this._getCommonOffset(appointment.endDate) - this._getCommonOffset(item.endDate);\r\n            if (0 === diffStartDateOffset && 0 === diffEndDateOffset) {\r\n                return item\r\n            }\r\n            diffStartDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\r\n            diffEndDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\r\n            var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\r\n            var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\r\n            var testNewStartDate = this.timeZoneCalculator.createDate(newStartDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            var testNewEndDate = this.timeZoneCalculator.createDate(newEndDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\r\n                newEndDate = new Date(newStartDate.getTime() + appointment.duration)\r\n            }\r\n            return _extends({}, item, {\r\n                startDate: newStartDate,\r\n                endDate: newEndDate,\r\n                exceptionDate: new Date(newStartDate)\r\n            })\r\n        })\r\n    }\r\n    _getProcessedLongAppointmentsIfRequired(gridAppointmentList, appointment) {\r\n        var rawAppointment = appointment.source();\r\n        var allDay = this.scheduler.appointmentTakesAllDay(rawAppointment);\r\n        var dateRange = this.workspace.getDateRange();\r\n        var renderingStrategy = this.scheduler.getLayoutManager().getRenderingStrategyInstance();\r\n        if (renderingStrategy.needSeparateAppointment(allDay)) {\r\n            var longStartDateParts = [];\r\n            var resultDates = [];\r\n            gridAppointmentList.forEach(gridAppointment => {\r\n                var maxDate = new Date(dateRange[1]);\r\n                var endDateOfPart = renderingStrategy.normalizeEndDateByViewEnd(rawAppointment, gridAppointment.endDate);\r\n                longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\r\n                    milliseconds: this.scheduler.getWorkSpace().getIntervalDuration(allDay)\r\n                });\r\n                var list = longStartDateParts.filter(startDatePart => new Date(startDatePart) < maxDate).map(date => ({\r\n                    startDate: date,\r\n                    endDate: new Date(new Date(date).setMilliseconds(appointment.duration)),\r\n                    source: gridAppointment.source\r\n                }));\r\n                resultDates = resultDates.concat(list)\r\n            });\r\n            gridAppointmentList = resultDates\r\n        }\r\n        return gridAppointmentList\r\n    }\r\n    _createGridAppointmentList(appointmentList, appointment) {\r\n        return appointmentList.map(source => {\r\n            var offsetDifference = appointment.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\r\n            if (0 !== offsetDifference && this._canProcessNotNativeTimezoneDates(appointment)) {\r\n                source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\r\n                source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\r\n                source.exceptionDate = new Date(source.startDate)\r\n            }\r\n            var startDate = this.timeZoneCalculator.createDate(source.startDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            var endDate = this.timeZoneCalculator.createDate(source.endDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            return {\r\n                startDate: startDate,\r\n                endDate: endDate,\r\n                source: source\r\n            }\r\n        })\r\n    }\r\n    _createExtremeRecurrenceDates(rawAppointment) {\r\n        var dateRange = this.scheduler._workSpace.getDateRange();\r\n        var startViewDate = this.scheduler.appointmentTakesAllDay(rawAppointment) ? dateUtils.trimTime(dateRange[0]) : dateRange[0];\r\n        var endViewDate = dateRange[1];\r\n        var commonTimeZone = this.scheduler.option(\"timeZone\");\r\n        if (commonTimeZone) {\r\n            startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\r\n                path: \"fromGrid\"\r\n            });\r\n            endViewDate = this.timeZoneCalculator.createDate(endViewDate, {\r\n                path: \"fromGrid\"\r\n            });\r\n            var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDate);\r\n            if (daylightOffset) {\r\n                endViewDate = new Date(endViewDate.getTime() + daylightOffset)\r\n            }\r\n        }\r\n        return [startViewDate, endViewDate]\r\n    }\r\n    _createRecurrenceOptions(appointment, groupIndex) {\r\n        var [minRecurrenceDate, maxRecurrenceDate] = this._createExtremeRecurrenceDates(appointment.source(), groupIndex);\r\n        return {\r\n            rule: appointment.recurrenceRule,\r\n            exception: appointment.recurrenceException,\r\n            min: minRecurrenceDate,\r\n            max: maxRecurrenceDate,\r\n            firstDayOfWeek: this.scheduler.getFirstDayOfWeek(),\r\n            start: appointment.startDate,\r\n            end: appointment.endDate,\r\n            getPostProcessedException: date => {\r\n                var timeZoneName = this.scheduler.option(\"timeZone\");\r\n                if (isEmptyObject(timeZoneName) || timeZoneUtils.isEqualLocalTimeZone(timeZoneName, date)) {\r\n                    return date\r\n                }\r\n                var appointmentOffset = this.timeZoneCalculator.getOffsets(appointment.startDate).common;\r\n                var exceptionAppointmentOffset = this.timeZoneCalculator.getOffsets(date).common;\r\n                var diff = appointmentOffset - exceptionAppointmentOffset;\r\n                diff = this._getProcessedNotNativeDateIfCrossDST(date, diff);\r\n                return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"))\r\n            }\r\n        }\r\n    }\r\n    _createRecurrenceAppointments(appointment, resources) {\r\n        var {\r\n            duration: duration\r\n        } = appointment;\r\n        var option = this._createRecurrenceOptions(appointment);\r\n        var generatedStartDates = getRecurrenceProcessor().generateDates(option);\r\n        return generatedStartDates.map(date => {\r\n            var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\r\n            utcDate.setTime(utcDate.getTime() + duration);\r\n            var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\r\n            return {\r\n                startDate: new Date(date),\r\n                endDate: endDate\r\n            }\r\n        })\r\n    }\r\n    _cropAppointmentsByStartDayHour(appointments, rawAppointment, isAllDay) {\r\n        return appointments.map(appointment => {\r\n            var startDate = new Date(appointment.startDate);\r\n            var firstViewDate = this._getAppointmentFirstViewDate(appointment, rawAppointment);\r\n            var startDayHour = this._getViewStartDayHour(firstViewDate);\r\n            appointment.startDate = this._getAppointmentResultDate({\r\n                appointment: appointment,\r\n                rawAppointment: rawAppointment,\r\n                startDate: startDate,\r\n                startDayHour: startDayHour,\r\n                firstViewDate: firstViewDate\r\n            });\r\n            return appointment\r\n        })\r\n    }\r\n    _getAppointmentFirstViewDate() {\r\n        return this.scheduler.getStartViewDate()\r\n    }\r\n    _getViewStartDayHour() {\r\n        return this.scheduler._getCurrentViewOption(\"startDayHour\")\r\n    }\r\n    _getAppointmentResultDate(options) {\r\n        var {\r\n            appointment: appointment,\r\n            rawAppointment: rawAppointment,\r\n            startDayHour: startDayHour,\r\n            firstViewDate: firstViewDate\r\n        } = options;\r\n        var {\r\n            startDate: startDate\r\n        } = options;\r\n        var resultDate = new Date(appointment.startDate);\r\n        if (this.scheduler.appointmentTakesAllDay(rawAppointment)) {\r\n            resultDate = dateUtils.normalizeDate(startDate, firstViewDate)\r\n        } else {\r\n            if (startDate < firstViewDate) {\r\n                startDate = firstViewDate\r\n            }\r\n            resultDate = dateUtils.normalizeDate(appointment.startDate, startDate)\r\n        }\r\n        return dateUtils.roundDateByStartDayHour(resultDate, startDayHour)\r\n    }\r\n    createAppointmentInfos(gridAppointments, resources, isAllDay, recurrent) {\r\n        var _this = this;\r\n        var result = [];\r\n        var _loop = function(i) {\r\n            var appointment = gridAppointments[i];\r\n            var coordinates = _this.getCoordinates({\r\n                appointment: appointment,\r\n                resources: resources,\r\n                isAllDay: isAllDay,\r\n                recurrent: recurrent\r\n            });\r\n            coordinates.forEach(coordinate => {\r\n                extend(coordinate, {\r\n                    info: {\r\n                        appointment: gridAppointments[i],\r\n                        sourceAppointment: gridAppointments[i].source\r\n                    }\r\n                })\r\n            });\r\n            result = result.concat(coordinates)\r\n        };\r\n        for (var i = 0; i < gridAppointments.length; i++) {\r\n            _loop(i)\r\n        }\r\n        return result\r\n    }\r\n    getCoordinates(options) {\r\n        var {\r\n            appointment: appointment,\r\n            resources: resources,\r\n            isAllDay: isAllDay\r\n        } = options;\r\n        return this.workspace.getCoordinatesByDateInGroup(appointment.startDate, resources, isAllDay)\r\n    }\r\n}\r\nexport class AppointmentSettingsGeneratorVirtualStrategy extends AppointmentSettingsGeneratorBaseStrategy {\r\n    get viewDataProvider() {\r\n        return this.workspace.viewDataProvider\r\n    }\r\n    get isVerticalGrouping() {\r\n        return this.workspace._isVerticalGroupedWorkSpace()\r\n    }\r\n    createAppointmentInfos(gridAppointments, resources, allDay, recurrent) {\r\n        var appointments = allDay ? gridAppointments : gridAppointments.filter(_ref => {\r\n            var {\r\n                source: source,\r\n                startDate: startDate,\r\n                endDate: endDate\r\n            } = _ref;\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = source;\r\n            return this.viewDataProvider.isGroupIntersectDateInterval(groupIndex, startDate, endDate)\r\n        });\r\n        if (recurrent) {\r\n            return this._createRecurrentAppointmentInfos(appointments, resources, allDay)\r\n        }\r\n        return super.createAppointmentInfos(appointments, resources, allDay, recurrent)\r\n    }\r\n    getCoordinates(options) {\r\n        var {\r\n            appointment: appointment,\r\n            isAllDay: isAllDay,\r\n            resources: resources,\r\n            recurrent: recurrent\r\n        } = options;\r\n        var {\r\n            startDate: startDate\r\n        } = appointment;\r\n        var {\r\n            workspace: workspace\r\n        } = this;\r\n        var groupIndex = !recurrent ? appointment.source.groupIndex : void 0;\r\n        return workspace.getCoordinatesByDateInGroup(startDate, resources, isAllDay, groupIndex)\r\n    }\r\n    _createRecurrentAppointmentInfos(gridAppointments, resources, allDay) {\r\n        var result = [];\r\n        gridAppointments.forEach(appointment => {\r\n            var {\r\n                source: source\r\n            } = appointment;\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = source;\r\n            var coordinate = this.workspace.getCoordinatesByDate(appointment.startDate, groupIndex, allDay);\r\n            if (coordinate) {\r\n                extend(coordinate, {\r\n                    info: {\r\n                        appointment: appointment,\r\n                        sourceAppointment: source\r\n                    }\r\n                });\r\n                result.push(coordinate)\r\n            }\r\n        });\r\n        return result\r\n    }\r\n    _cropAppointmentsByStartDayHour(appointments, rawAppointment, isAllDay) {\r\n        return appointments.filter(appointment => {\r\n            var firstViewDate = this._getAppointmentFirstViewDate(appointment, rawAppointment);\r\n            if (!firstViewDate) {\r\n                return false\r\n            }\r\n            var startDayHour = this._getViewStartDayHour(firstViewDate);\r\n            var startDate = new Date(appointment.startDate);\r\n            appointment.startDate = this._getAppointmentResultDate({\r\n                appointment: appointment,\r\n                rawAppointment: rawAppointment,\r\n                startDate: startDate,\r\n                startDayHour: startDayHour,\r\n                firstViewDate: firstViewDate\r\n            });\r\n            return !isAllDay ? appointment.endDate > appointment.startDate : true\r\n        })\r\n    }\r\n    _createRecurrenceAppointments(appointment, resources) {\r\n        var {\r\n            duration: duration\r\n        } = appointment;\r\n        var result = [];\r\n        var groupIndices = this.workspace._getGroupCount() ? this._getGroupIndices(resources) : [0];\r\n        groupIndices.forEach(groupIndex => {\r\n            var option = this._createRecurrenceOptions(appointment, groupIndex);\r\n            var generatedStartDates = getRecurrenceProcessor().generateDates(option);\r\n            var recurrentInfo = generatedStartDates.map(date => {\r\n                var startDate = new Date(date);\r\n                var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\r\n                utcDate.setTime(utcDate.getTime() + duration);\r\n                var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\r\n                return {\r\n                    startDate: startDate,\r\n                    endDate: endDate,\r\n                    groupIndex: groupIndex\r\n                }\r\n            });\r\n            result.push(...recurrentInfo)\r\n        });\r\n        return result\r\n    }\r\n    _getViewStartDayHour(firstViewDate) {\r\n        return firstViewDate.getHours()\r\n    }\r\n    _getAppointmentFirstViewDate(appointment, rawAppointment) {\r\n        var {\r\n            viewDataProvider: viewDataProvider\r\n        } = this.scheduler.getWorkSpace();\r\n        var {\r\n            groupIndex: groupIndex\r\n        } = appointment.source;\r\n        var {\r\n            startDate: startDate,\r\n            endDate: endDate\r\n        } = appointment;\r\n        var isAllDay = this._isAllDayAppointment(rawAppointment);\r\n        return viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay)\r\n    }\r\n    _updateGroupIndices(appointments, itemResources) {\r\n        var groupIndices = this._getGroupIndices(itemResources);\r\n        var result = [];\r\n        groupIndices.forEach(groupIndex => {\r\n            var groupStartDate = this.viewDataProvider.getGroupStartDate(groupIndex);\r\n            if (groupStartDate) {\r\n                appointments.forEach(appointment => {\r\n                    var appointmentCopy = extend({}, appointment);\r\n                    appointmentCopy.groupIndex = groupIndex;\r\n                    result.push(appointmentCopy)\r\n                })\r\n            }\r\n        });\r\n        return result\r\n    }\r\n    _getGroupIndices(resources) {\r\n        var _groupIndices;\r\n        var groupIndices = this.workspace._getGroupIndexes(resources);\r\n        var {\r\n            viewDataProvider: viewDataProvider\r\n        } = this.workspace;\r\n        var viewDataGroupIndices = viewDataProvider.getGroupIndices();\r\n        if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {\r\n            groupIndices = [0]\r\n        }\r\n        return groupIndices.filter(groupIndex => -1 !== viewDataGroupIndices.indexOf(groupIndex))\r\n    }\r\n    _createAppointments(appointment, resources) {\r\n        var appointments = super._createAppointments(appointment, resources);\r\n        return !appointment.isRecurrent ? this._updateGroupIndices(appointments, resources) : appointments\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}